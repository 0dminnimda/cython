#!/usr/bin/env python3.8
# @generated by pegen from Cython/Parser/Cython.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser

import enum
import io
import itertools
import os
import sys
import token
from typing import Any, Callable, Iterator, List, Literal, NoReturn, Tuple, TypeVar, Union

from .. import Utils
from ..Compiler import Builtin, ExprNodes, Nodes
from ..Compiler.Main import CompilationSource, Context
from ..Compiler.Options import CompilationOptions, default_options
from ..Compiler.Scanning import FileSourceDescriptor
from ..Compiler.StringEncoding import EncodedString

# Singleton ast nodes, created once for efficiency
Load = ast.Load()
Store = ast.Store()
Del = ast.Del()

Node = TypeVar("Node")
FC = TypeVar("FC", ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)

EXPR_NAME_MAPPING = {
    ast.Attribute: "attribute",
    ast.Subscript: "subscript",
    ast.Starred: "starred",
    ast.Name: "name",
    ast.List: "list",
    ast.Tuple: "tuple",
    ast.Lambda: "lambda",
    ast.Call: "function call",
    ast.BoolOp: "expression",
    ast.BinOp: "expression",
    ast.UnaryOp: "expression",
    ast.GeneratorExp: "generator expression",
    ast.Yield: "yield expression",
    ast.YieldFrom: "yield expression",
    ast.Await: "await expression",
    ast.ListComp: "list comprehension",
    ast.SetComp: "set comprehension",
    ast.DictComp: "dict comprehension",
    ast.Dict: "dict literal",
    ast.Set: "set display",
    ast.JoinedStr: "f-string expression",
    ast.FormattedValue: "f-string expression",
    ast.Compare: "comparison",
    ast.IfExp: "conditional expression",
    ast.NamedExpr: "named expression",
}


class Target(enum.Enum):
    FOR_TARGETS = enum.auto()
    STAR_TARGETS = enum.auto()
    DEL_TARGETS = enum.auto()


class Parser(Parser):

    #: Name of the source file, used in error reports
    filename : str

    def __init__(self,
        tokenizer: Tokenizer,
        source_desc, *,
        verbose: bool = False,
        filename: str = "<unknown>",
        py_version: Optional[tuple] = None,
    ) -> None:
        super().__init__(tokenizer, verbose=verbose)
        self.filename = filename
        self.py_version = min(py_version, sys.version_info) if py_version else sys.version_info
        self.source_desc = source_desc

    def parse(self, rule: str, call_invalid_rules: bool = False) -> Optional[ast.AST]:
        self.call_invalid_rules = call_invalid_rules
        res = getattr(self, rule)()

        if res is None:

            # Grab the last token that was parsed in the first run to avoid
            # polluting a generic error reports with progress made by invalid rules.
            last_token = self._tokenizer.diagnose()

            if not call_invalid_rules:
                self.call_invalid_rules = True

                # Reset the parser cache to be able to restart parsing from the
                # beginning.
                self._reset(0)  # type: ignore
                self._cache.clear()

                res = getattr(self, rule)()

            self.raise_raw_syntax_error("invalid syntax", last_token.start, last_token.end)

        return res

    def pos(self, lineno, col_offset, end_lineno, end_col_offset):
        return (self.source_desc, lineno, col_offset)

    def check_version(self, min_version: Tuple[int, ...], error_msg: str, node: Node) -> Node:
        """Check that the python version is high enough for a rule to apply.

        """
        if self.py_version >= min_version:
            return node
        else:
            raise SyntaxError(
                f"{error_msg} is only supported in Python {min_version} and above."
            )

    def raise_indentation_error(self, msg: str) -> None:
        """Raise an indentation error."""
        last_token = self._tokenizer.diagnose()
        args = (self.filename, last_token.start[0], last_token.start[1] + 1, last_token.line)
        if sys.version_info >= (3, 10):
            args += (last_token.end[0], last_token.end[1] + 1)
        raise IndentationError(msg, args)

    def get_expr_name(self, node) -> str:
        """Get a descriptive name for an expression."""
        # See https://github.com/python/cpython/blob/master/Parser/pegen.c#L161
        assert node is not None
        node_t = type(node)
        if node_t is ast.Constant:
            v = node.value
            if v is Ellipsis:
                return "ellipsis"
            elif v is None:
                return str(v)
            # Avoid treating 1 as True through == comparison
            elif v is True:
                return str(v)
            elif v is False:
                return str(v)
            else:
                return "literal"

        try:
            return EXPR_NAME_MAPPING[node_t]
        except KeyError:
            raise ValueError(
                f"unexpected expression in assignment {type(node).__name__} "
                f"(line {node.lineno})."
            )

    def get_invalid_target(self, target: Target, node: Optional[ast.AST]) -> Optional[ast.AST]:
        """Get the meaningful invalid target for different assignment type."""
        if node is None:
            return None

        # We only need to visit List and Tuple nodes recursively as those
        # are the only ones that can contain valid names in targets when
        # they are parsed as expressions. Any other kind of expression
        # that is a container (like Sets or Dicts) is directly invalid and
        # we do not need to visit it recursively.
        if isinstance(node, (ast.List, ast.Tuple)):
            for e in node.elts:
                if (inv := self.get_invalid_target(target, e)) is not None:
                    return inv
        elif isinstance(node, ast.Starred):
            if target is Target.DEL_TARGETS:
                return node
            return self.get_invalid_target(target, node.value)
        elif isinstance(node, ast.Compare):
            # This is needed, because the `a in b` in `for a in b` gets parsed
            # as a comparison, and so we need to search the left side of the comparison
            # for invalid targets.
            if target is Target.FOR_TARGETS:
                if isinstance(node.ops[0], ast.In):
                    return self.get_invalid_target(target, node.left)
                return None

            return node
        elif isinstance(node, (ast.Name, ast.Subscript, ast.Attribute)):
            return None
        else:
            return node

    def set_expr_context(self, node, context):
        """Set the context (Load, Store, Del) of an ast node."""
        node.ctx = context
        return node

    def ensure_real(self, number: ast.Constant):
        value = ast.literal_eval(number.string)
        if type(value) is complex:
            self.raise_syntax_error_known_location("real number required in complex literal", number)
        return value

    def ensure_imaginary(self, number:  ast.Constant):
        value = ast.literal_eval(number.string)
        if type(value) is not complex:
            self.raise_syntax_error_known_location("imaginary number required in complex literal", number)
        return value

    def generate_ast_for_string(self, tokens):
        """Generate AST nodes for strings."""
        err_args = None
        line_offset = tokens[0].start[0]
        line = line_offset
        col_offset = 0
        source = "(\n"
        for t in tokens:
            n_line = t.start[0] - line
            if n_line:
                col_offset = 0
            source += """\n""" * n_line + ' ' * (t.start[1] - col_offset) + t.string
            line, col_offset = t.end
        source += "\n)"
        try:
            m = ast.parse(source)
        except SyntaxError as err:
            args = (err.filename, err.lineno + line_offset - 2, err.offset, err.text)
            if sys.version_info >= (3, 10):
                args += (err.end_lineno + line_offset - 2, err.end_offset)
            err_args = (err.msg, args)
            # Ensure we do not keep the frame alive longer than necessary
            # by explicitely deleting the error once we got what we needed out
            # of it
            del err

        # Avoid getting a triple nesting in the error report that does not
        # bring anything relevant to the traceback.
        if err_args is not None:
            raise SyntaxError(*err_args)

        node = m.body[0].value
        # Since we asked Python to parse an alterred source starting at line 2
        # we alter the lineno of the returned AST to recover the right line.
        # If the string start at line 1, tha AST says 2 so we need to decrement by 1
        # hence the -2.
        ast.increment_lineno(node, line_offset - 2)
        return node

    def extract_import_level(self, tokens: List[tokenize.TokenInfo]) -> int:
        """Extract the relative import level from the tokens preceding the module name.

        '.' count for one and '...' for 3.

        """
        level = 0
        for t in tokens:
            if t.string == ".":
                level += 1
            else:
                level += 3
        return level

    def set_decorators(self,
        target: FC,
        decorators: list
    ) -> FC:
        """Set the decorators on a function or class definition."""
        target.decorator_list = decorators
        return target

    def get_comparison_ops(self, pairs):
        return [op for op, _ in pairs]

    def get_comparators(self, pairs):
        return [comp for _, comp in pairs]

    def set_arg_type_comment(self, arg, type_comment):
        if type_comment or sys.version_info < (3, 9):
            arg.type_comment = type_comment
        return arg

    def make_arguments(self,
        pos_only: Optional[List[Tuple[ast.arg, None]]],
        pos_only_with_default: List[Tuple[ast.arg, Any]],
        param_no_default: Optional[List[Tuple[ast.arg, None]]],
        param_default: Optional[List[Tuple[ast.arg, Any]]],
        after_star: Optional[Tuple[Optional[ast.arg], List[Tuple[ast.arg, Any]], Optional[ast.arg]]]
    ) -> ast.arguments:
        """Build a function definition arguments."""
        defaults = (
            [d for _, d in pos_only_with_default if d is not None]
            if pos_only_with_default else
            []
        )
        defaults += (
            [d for _, d in param_default if d is not None]
            if param_default else
            []
        )

        pos_only = pos_only or pos_only_with_default

        # Because we need to combine pos only with and without default even
        # the version with no default is a tuple
        pos_only = [p for p, _ in pos_only]
        params = (param_no_default or []) + ([p for p, _ in param_default] if param_default else [])

        # If after_star is None, make a default tuple
        after_star = after_star or (None, [], None)

        return ast.arguments(
            posonlyargs=pos_only,
            args=params,
            defaults=defaults,
            vararg=after_star[0],
            kwonlyargs=[p for p, _ in after_star[1]],
            kw_defaults=[d for _, d in after_star[1]],
            kwarg=after_star[2]
        )

    def _build_syntax_error(
        self,
        message: str,
        start: Optional[Tuple[int, int]] = None,
        end: Optional[Tuple[int, int]] = None
    ) -> None:
        line_from_token = start is None and end is None
        if start is None or end is None:
            tok = self._tokenizer.diagnose()
            start = start or tok.start
            end = end or tok.end

        if line_from_token:
            line = tok.line
        else:
            # End is used only to get the proper text
            line = "\n".join(
                self._tokenizer.get_lines(list(range(start[0], end[0] + 1)))
            )

        # tokenize.py index column offset from 0 while Cpython index column
        # offset at 1 when reporting SyntaxError, so we need to increment
        # the column offset when reporting the error.
        args = (self.filename, start[0], start[1] + 1, line)
        if sys.version_info >= (3, 10):
            args += (end[0], end[1] + 1)

        return SyntaxError(message, args)

    def raise_raw_syntax_error(
        self,
        message: str,
        start: Optional[Tuple[int, int]] = None,
        end: Optional[Tuple[int, int]] = None
    ) -> NoReturn:
        raise self._build_syntax_error(message, start, end)

    def make_syntax_error(self, message: str) -> None:
        return self._build_syntax_error(message)

    def expect_forced(self, res: Any, expectation: str) -> Optional[tokenize.TokenInfo]:
        if res is None:
            last_token = self._tokenizer.diagnose()
            self.raise_raw_syntax_error(
                f"expected {expectation}", last_token.start, last_token.start
            )
        return res

    def raise_syntax_error(self, message: str) -> NoReturn:
        """Raise a syntax error."""
        tok = self._tokenizer.diagnose()
        raise self._build_syntax_error(message, tok.start, tok.end if tok.type != 4 else tok.start)

    def raise_syntax_error_known_location(
        self, message: str, node: Union[ast.AST, tokenize.TokenInfo]
    ) -> NoReturn:
        """Raise a syntax error that occured at a given AST node."""
        if isinstance(node, tokenize.TokenInfo):
            start = node.start
            end = node.end
        else:
            start = node.lineno, node.col_offset
            end = node.end_lineno, node.end_col_offset

        raise self._build_syntax_error(message, start, end)

    def raise_syntax_error_known_range(
        self,
        message: str,
        start_node: Union[ast.AST, tokenize.TokenInfo],
        end_node: Union[ast.AST, tokenize.TokenInfo]
    ) -> NoReturn:
        if isinstance(start_node, tokenize.TokenInfo):
            start = start_node.start
        else:
            start = start_node.lineno, start_node.col_offset

        if isinstance(end_node, tokenize.TokenInfo):
            end = end_node.end
        else:
            end = end_node.end_lineno, end_node.end_col_offset

        raise self._build_syntax_error(message, start, end)

    def raise_syntax_error_starting_from(
        self,
        message: str,
        start_node: Union[ast.AST, tokenize.TokenInfo]
    ) -> NoReturn:
        if isinstance(start_node, tokenize.TokenInfo):
            start = start_node.start
        else:
            start = start_node.lineno, start_node.col_offset

        last_token = self._tokenizer.diagnose()

        raise self._build_syntax_error(message, start, last_token.start)

    def raise_syntax_error_invalid_target(
        self, target: Target, node: Optional[ast.AST]
    ) -> NoReturn:
        invalid_target = self.get_invalid_target(target, node)

        if invalid_target is None:
            return None

        if target in (Target.STAR_TARGETS, Target.FOR_TARGETS):
            msg = f"cannot assign to {self.get_expr_name(invalid_target)}"
        else:
            msg = f"cannot delete {self.get_expr_name(invalid_target)}"

        self.raise_syntax_error_known_location(msg, invalid_target)


# Keywords and soft keywords are listed at the end of the parser definition.
class CythonParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: file
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = file = self.file()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return file;
        self._reset(mark)
        return None;

    @memoize
    def file(self) -> Optional[ast . Module]:
        # file: statements? $
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            a = self.statements()
            __last = True
            if not __last: break
            __last = _endmarker = self.expect('ENDMARKER')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Module ( body = a or [] , type_ignores = [] );
        self._reset(mark)
        return None;

    @memoize
    def interactive(self) -> Optional[ast . Interactive]:
        # interactive: statement_newline
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.statement_newline()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Interactive ( body = a );
        self._reset(mark)
        return None;

    @memoize
    def eval(self) -> Optional[ast . Expression]:
        # eval: expressions NEWLINE* $
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expressions()
            if not __last: break
            _loop0_1 = self._loop0_1()
            __last = True
            if not __last: break
            __last = _endmarker = self.expect('ENDMARKER')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Expression ( body = a );
        self._reset(mark)
        return None;

    @memoize
    def func_type(self) -> Optional[ast . FunctionType]:
        # func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            a = self.type_expressions()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __last = literal_2 = self.expect('->')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            _loop0_2 = self._loop0_2()
            __last = True
            if not __last: break
            __last = _endmarker = self.expect('ENDMARKER')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . FunctionType ( argtypes = a , returns = b );
        self._reset(mark)
        return None;

    @memoize
    def fstring(self) -> Optional[ast . Expr]:
        # fstring: star_expressions
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_expressions = self.star_expressions()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_expressions;
        self._reset(mark)
        return None;

    @memoize
    def statements(self) -> Optional[list]:
        # statements: statement+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_3()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return list ( itertools . chain . from_iterable ( a ) );
        self._reset(mark)
        return None;

    @memoize
    def statement(self) -> Optional[list]:
        # statement: compound_stmt | simple_stmts
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.compound_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.simple_stmts()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def statement_newline(self) -> Optional[list]:
        # statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.compound_stmt()
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = simple_stmts = self.simple_stmts()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return simple_stmts;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return [ast . Pass ( lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _endmarker = self.expect('ENDMARKER')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None;
        self._reset(mark)
        return None;

    @memoize
    def simple_stmts(self) -> Optional[list]:
        # simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.simple_stmt()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ';')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_4()
            if not __last: break
            opt = self.expect(';')
            __last = True
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def simple_stmt(self) -> Optional[Any]:
        # simple_stmt: assignment | star_expressions | &'return' return_stmt | &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del' del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' | 'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = assignment = self.assignment()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return assignment;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = e = self.star_expressions()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Expr ( value = e , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'return')
            if not __last: break
            __last = return_stmt = self.return_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return return_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self._tmp_6, )
            if not __last: break
            __last = import_stmt = self.import_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return import_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'raise')
            if not __last: break
            __last = raise_stmt = self.raise_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return raise_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('pass')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Pass ( lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'del')
            if not __last: break
            __last = del_stmt = self.del_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return del_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'yield')
            if not __last: break
            __last = yield_stmt = self.yield_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return yield_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'assert')
            if not __last: break
            __last = assert_stmt = self.assert_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return assert_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('break')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Break ( lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('continue')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Continue ( lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'global')
            if not __last: break
            __last = global_stmt = self.global_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return global_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'nonlocal')
            if not __last: break
            __last = nonlocal_stmt = self.nonlocal_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return nonlocal_stmt;
        self._reset(mark)
        return None;

    @memoize
    def compound_stmt(self) -> Optional[Any]:
        # compound_stmt: &('def' | '@' | 'async') function_def | &'if' if_stmt | &('class' | '@') class_def | &('with' | 'async') with_stmt | &('for' | 'async') for_stmt | &'try' try_stmt | &'while' while_stmt | match_stmt
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self._tmp_7, )
            if not __last: break
            __last = function_def = self.function_def()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return function_def;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'if')
            if not __last: break
            __last = if_stmt = self.if_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return if_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self._tmp_8, )
            if not __last: break
            __last = class_def = self.class_def()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return class_def;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self._tmp_9, )
            if not __last: break
            __last = with_stmt = self.with_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return with_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self._tmp_10, )
            if not __last: break
            __last = for_stmt = self.for_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return for_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'try')
            if not __last: break
            __last = try_stmt = self.try_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return try_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, 'while')
            if not __last: break
            __last = while_stmt = self.while_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return while_stmt;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = match_stmt = self.match_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return match_stmt;
        self._reset(mark)
        return None;

    @memoize
    def assignment(self) -> Optional[Any]:
        # assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT? | single_target augassign ~ (yield_expr | star_expressions) | invalid_assignment
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            c = self._tmp_11()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 6 ) , "Variable annotation syntax is" , ast . AnnAssign ( target = ast . Name ( id = a . string , ctx = Store , lineno = a . start [0] , col_offset = a . start [1] , end_lineno = a . end [0] , end_col_offset = a . end [1] , ) , annotation = b , value = c , simple = 1 , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._tmp_12()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            c = self._tmp_13()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 6 ) , "Variable annotation syntax is" , ast . AnnAssign ( target = a , annotation = b , value = c , simple = 0 , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_14()
            if not __last: break
            __last = b = self._tmp_15()
            if not __last: break
            __last = self.negative_lookahead(self.expect, '=')
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Assign ( targets = a , value = b , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        cut = False
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.single_target()
            if not __last: break
            __last = b = self.augassign()
            if not __last: break
            __last = cut = True
            if not __last: break
            __last = c = self._tmp_16()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . AugAssign ( target = a , op = b , value = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        if cut:
            return None;
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_assignment = self.invalid_assignment()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def annotated_rhs(self) -> Optional[Any]:
        # annotated_rhs: yield_expr | star_expressions
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = yield_expr = self.yield_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return yield_expr;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_expressions = self.star_expressions()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_expressions;
        self._reset(mark)
        return None;

    @memoize
    def augassign(self) -> Optional[Any]:
        # augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('+=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Add ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('-=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Sub ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Mult ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('@=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . check_version ( ( 3 , 5 ) , "The '@' operator is" , ast . MatMult ( ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('/=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Div ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('%=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Mod ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('&=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . BitAnd ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('|=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . BitOr ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('^=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . BitXor ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('<<=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . LShift ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('>>=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . RShift ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . Pow ( );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('//=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . FloorDiv ( );
        self._reset(mark)
        return None;

    @memoize
    def return_stmt(self) -> Optional[ast . Return]:
        # return_stmt: 'return' star_expressions?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('return')
            if not __last: break
            a = self.star_expressions()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Return ( value = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def raise_stmt(self) -> Optional[ast . Raise]:
        # raise_stmt: 'raise' expression ['from' expression] | 'raise'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('raise')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            b = self._tmp_17()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Raise ( exc = a , cause = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('raise')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Raise ( exc = None , cause = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def global_stmt(self) -> Optional[ast . Global]:
        # global_stmt: 'global' ','.NAME+
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('global')
            if not __last: break
            __last = a = self._gather_18()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Global ( names = [n . string for n in a] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def nonlocal_stmt(self) -> Optional[ast . Nonlocal]:
        # nonlocal_stmt: 'nonlocal' ','.NAME+
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('nonlocal')
            if not __last: break
            __last = a = self._gather_20()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Nonlocal ( names = [n . string for n in a] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def del_stmt(self) -> Optional[ast . Delete]:
        # del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('del')
            if not __last: break
            __last = a = self.del_targets()
            if not __last: break
            __last = self.positive_lookahead(self._tmp_22, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Delete ( targets = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_del_stmt = self.invalid_del_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def yield_stmt(self) -> Optional[ast . Expr]:
        # yield_stmt: yield_expr
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = y = self.yield_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Expr ( value = y , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def assert_stmt(self) -> Optional[ast . Assert]:
        # assert_stmt: 'assert' expression [',' expression]
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('assert')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            b = self._tmp_23()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Assert ( test = a , msg = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def import_stmt(self) -> Optional[ast . Import]:
        # import_stmt: import_name | import_from
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = import_name = self.import_name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return import_name;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = import_from = self.import_from()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return import_from;
        self._reset(mark)
        return None;

    @memoize
    def import_name(self) -> Optional[ast . Import]:
        # import_name: 'import' dotted_as_names
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('import')
            if not __last: break
            __last = a = self.dotted_as_names()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Import ( names = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def import_from(self) -> Optional[ast . ImportFrom]:
        # import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('from')
            if not __last: break
            a = self._loop0_24()
            __last = True
            if not __last: break
            __last = b = self.dotted_name()
            if not __last: break
            __last = literal_1 = self.expect('import')
            if not __last: break
            __last = c = self.import_from_targets()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . ImportFrom ( module = b , names = c , level = self . extract_import_level ( a ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('from')
            if not __last: break
            __last = a = self._loop1_25()
            if not __last: break
            __last = literal_1 = self.expect('import')
            if not __last: break
            __last = b = self.import_from_targets()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . ImportFrom ( names = b , level = self . extract_import_level ( a ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if sys . version_info >= ( 3 , 9 ) else ast . ImportFrom ( module = None , names = b , level = self . extract_import_level ( a ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def import_from_targets(self) -> Optional[List [ast . alias]]:
        # import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names !',' | '*' | invalid_import_from_targets
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self.import_from_as_names()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = import_from_as_names = self.import_from_as_names()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return import_from_as_names;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return [ast . alias ( name = "*" , asname = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_import_from_targets = self.invalid_import_from_targets()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def import_from_as_names(self) -> Optional[List [ast . alias]]:
        # import_from_as_names: ','.import_from_as_name+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_26()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def import_from_as_name(self) -> Optional[ast . alias]:
        # import_from_as_name: NAME ['as' NAME]
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            b = self._tmp_28()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . alias ( name = a . string , asname = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def dotted_as_names(self) -> Optional[List [ast . alias]]:
        # dotted_as_names: ','.dotted_as_name+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_29()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def dotted_as_name(self) -> Optional[ast . alias]:
        # dotted_as_name: dotted_name ['as' NAME]
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.dotted_name()
            if not __last: break
            b = self._tmp_31()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . alias ( name = a , asname = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize_left_rec
    def dotted_name(self) -> Optional[str]:
        # dotted_name: dotted_name '.' NAME | NAME
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.dotted_name()
            if not __last: break
            __last = literal = self.expect('.')
            if not __last: break
            __last = b = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a + "." + b . string;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a . string;
        self._reset(mark)
        return None;

    @memoize
    def block(self) -> Optional[list]:
        # block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = _indent = self.expect('INDENT')
            if not __last: break
            __last = a = self.statements()
            if not __last: break
            __last = _dedent = self.expect('DEDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = simple_stmts = self.simple_stmts()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return simple_stmts;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_block = self.invalid_block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def decorators(self) -> Optional[Any]:
        # decorators: decorator+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _loop1_32 = self._loop1_32()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _loop1_32;
        self._reset(mark)
        return None;

    @memoize
    def decorator(self) -> Optional[Any]:
        # decorator: ('@' dec_maybe_call NEWLINE) | ('@' named_expression NEWLINE)
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._tmp_33()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._tmp_34()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . check_version ( ( 3 , 9 ) , "Generic decorator are" , a );
        self._reset(mark)
        return None;

    @memoize
    def dec_maybe_call(self) -> Optional[Any]:
        # dec_maybe_call: dec_primary '(' arguments? ')' | dec_primary
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = dn = self.dec_primary()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            z = self.arguments()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Call ( func = dn , args = z [0] if z else [] , keywords = z [1] if z else [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = dec_primary = self.dec_primary()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return dec_primary;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def dec_primary(self) -> Optional[Any]:
        # dec_primary: dec_primary '.' NAME | NAME
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.dec_primary()
            if not __last: break
            __last = literal = self.expect('.')
            if not __last: break
            __last = b = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Attribute ( value = a , attr = b . string , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Name ( id = a . string , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def class_def(self) -> Optional[ast . ClassDef]:
        # class_def: decorators class_def_raw | class_def_raw
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.decorators()
            if not __last: break
            __last = b = self.class_def_raw()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . set_decorators ( b , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = class_def_raw = self.class_def_raw()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return class_def_raw;
        self._reset(mark)
        return None;

    @memoize
    def class_def_raw(self) -> Optional[ast . ClassDef]:
        # class_def_raw: invalid_class_def_raw | 'class' NAME ['(' arguments? ')'] &&':' block
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_class_def_raw = self.invalid_class_def_raw()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('class')
            if not __last: break
            __last = a = self.name()
            if not __last: break
            b = self._tmp_35()
            __last = True
            if not __last: break
            __last = forced = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            __last = c = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . ClassDef ( a . string , bases = b [0] if b else [] , keywords = b [1] if b else [] , body = c , decorator_list = [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        return None;

    @memoize
    def function_def(self) -> Optional[Union [ast . FunctionDef , ast . AsyncFunctionDef]]:
        # function_def: decorators function_def_raw | function_def_raw
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = d = self.decorators()
            if not __last: break
            __last = f = self.function_def_raw()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . set_decorators ( f , d );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = f = self.function_def_raw()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . set_decorators ( f , [] );
        self._reset(mark)
        return None;

    @memoize
    def function_def_raw(self) -> Optional[Union [ast . FunctionDef , ast . AsyncFunctionDef]]:
        # function_def_raw: invalid_def_raw | 'def' NAME &&'(' params? ')' ['->' expression] &&':' func_type_comment? block | 'async' 'def' NAME &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_def_raw = self.invalid_def_raw()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('def')
            if not __last: break
            __last = n = self.name()
            if not __last: break
            __last = forced = self.expect_forced(self.expect('('), "'('")
            if not __last: break
            params = self.params()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            a = self._tmp_36()
            __last = True
            if not __last: break
            __last = forced_1 = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            tc = self.func_type_comment()
            __last = True
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . FunctionDef ( name = n . string , args = params or self . make_arguments ( None , [] , None , [] , None ) , returns = a , body = b , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('async')
            if not __last: break
            __last = literal_1 = self.expect('def')
            if not __last: break
            __last = n = self.name()
            if not __last: break
            __last = forced = self.expect_forced(self.expect('('), "'('")
            if not __last: break
            params = self.params()
            __last = True
            if not __last: break
            __last = literal_2 = self.expect(')')
            if not __last: break
            a = self._tmp_37()
            __last = True
            if not __last: break
            __last = forced_1 = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            tc = self.func_type_comment()
            __last = True
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 5 ) , "Async functions are" , ast . AsyncFunctionDef ( name = n . string , args = params or self . make_arguments ( None , [] , None , [] , None ) , returns = a , body = b , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , ) );
        self._reset(mark)
        return None;

    @memoize
    def params(self) -> Optional[Any]:
        # params: invalid_parameters | parameters
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_parameters = self.invalid_parameters()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = parameters = self.parameters()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return parameters;
        self._reset(mark)
        return None;

    @memoize
    def parameters(self) -> Optional[ast . arguments]:
        # parameters: slash_no_default param_no_default* param_with_default* star_etc? | slash_with_default param_with_default* star_etc? | param_no_default+ param_with_default* star_etc? | param_with_default+ star_etc? | star_etc
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.slash_no_default()
            if not __last: break
            b = self._loop0_38()
            __last = True
            if not __last: break
            c = self._loop0_39()
            __last = True
            if not __last: break
            d = self.star_etc()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . check_version ( ( 3 , 8 ) , "Positional only arguments are" , self . make_arguments ( a , [] , b , c , d ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.slash_with_default()
            if not __last: break
            b = self._loop0_40()
            __last = True
            if not __last: break
            c = self.star_etc()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . check_version ( ( 3 , 8 ) , "Positional only arguments are" , self . make_arguments ( None , a , None , b , c ) , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_41()
            if not __last: break
            b = self._loop0_42()
            __last = True
            if not __last: break
            c = self.star_etc()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . make_arguments ( None , [] , a , b , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_43()
            if not __last: break
            b = self.star_etc()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . make_arguments ( None , [] , None , a , b );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_etc()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . make_arguments ( None , [] , None , None , a );
        self._reset(mark)
        return None;

    @memoize
    def slash_no_default(self) -> Optional[List [Tuple [ast . arg , None]]]:
        # slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_44()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [( p , None ) for p in a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_45()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = self.positive_lookahead(self.expect, ')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [( p , None ) for p in a];
        self._reset(mark)
        return None;

    @memoize
    def slash_with_default(self) -> Optional[List [Tuple [ast . arg , Any]]]:
        # slash_with_default: param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            a = self._loop0_46()
            __last = True
            if not __last: break
            __last = b = self._loop1_47()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( [( p , None ) for p in a] if a else [] ) + b;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            a = self._loop0_48()
            __last = True
            if not __last: break
            __last = b = self._loop1_49()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = self.positive_lookahead(self.expect, ')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( [( p , None ) for p in a] if a else [] ) + b;
        self._reset(mark)
        return None;

    @memoize
    def star_etc(self) -> Optional[Tuple [Optional [ast . arg] , List [Tuple [ast . arg , Any]] , Optional [ast . arg]]]:
        # star_etc: invalid_star_etc | '*' param_no_default param_maybe_default* kwds? | '*' ',' param_maybe_default+ kwds? | kwds
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_star_etc = self.invalid_star_etc()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = a = self.param_no_default()
            if not __last: break
            b = self._loop0_50()
            __last = True
            if not __last: break
            c = self.kwds()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( a , b , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = b = self._loop1_51()
            if not __last: break
            c = self.kwds()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( None , b , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.kwds()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( None , [] , a );
        self._reset(mark)
        return None;

    @memoize
    def kwds(self) -> Optional[ast . arg]:
        # kwds: invalid_kwds | '**' param_no_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_kwds = self.invalid_kwds()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = a = self.param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def param_no_default(self) -> Optional[ast . arg]:
        # param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.param()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . set_arg_type_comment ( a , tc );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.param()
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __last = self.positive_lookahead(self.expect, ')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . set_arg_type_comment ( a , tc );
        self._reset(mark)
        return None;

    @memoize
    def param_with_default(self) -> Optional[Tuple [ast . arg , Any]]:
        # param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.param()
            if not __last: break
            __last = c = self.default()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( self . set_arg_type_comment ( a , tc ) , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.param()
            if not __last: break
            __last = c = self.default()
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __last = self.positive_lookahead(self.expect, ')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( self . set_arg_type_comment ( a , tc ) , c );
        self._reset(mark)
        return None;

    @memoize
    def param_maybe_default(self) -> Optional[Tuple [ast . arg , Any]]:
        # param_maybe_default: param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.param()
            if not __last: break
            c = self.default()
            __last = True
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( self . set_arg_type_comment ( a , tc ) , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.param()
            if not __last: break
            c = self.default()
            __last = True
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __last = self.positive_lookahead(self.expect, ')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( self . set_arg_type_comment ( a , tc ) , c );
        self._reset(mark)
        return None;

    @memoize
    def param(self) -> Optional[Any]:
        # param: NAME annotation?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            b = self.annotation()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . arg ( arg = a . string , annotation = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def annotation(self) -> Optional[Any]:
        # annotation: ':' expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def default(self) -> Optional[Any]:
        # default: '=' expression | invalid_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('=')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_default = self.invalid_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def if_stmt(self) -> Optional[ast . If]:
        # if_stmt: invalid_if_stmt | 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block else_block?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_if_stmt = self.invalid_if_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('if')
            if not __last: break
            __last = a = self.named_expression()
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __last = c = self.elif_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . If ( test = a , body = b , orelse = c or [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('if')
            if not __last: break
            __last = a = self.named_expression()
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            c = self.else_block()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . If ( test = a , body = b , orelse = c or [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def elif_stmt(self) -> Optional[List [ast . If]]:
        # elif_stmt: invalid_elif_stmt | 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block else_block?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_elif_stmt = self.invalid_elif_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('elif')
            if not __last: break
            __last = a = self.named_expression()
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __last = c = self.elif_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return [ast . If ( test = a , body = b , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('elif')
            if not __last: break
            __last = a = self.named_expression()
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            c = self.else_block()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return [ast . If ( test = a , body = b , orelse = c or [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )];
        self._reset(mark)
        return None;

    @memoize
    def else_block(self) -> Optional[list]:
        # else_block: invalid_else_stmt | 'else' &&':' block
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_else_stmt = self.invalid_else_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('else')
            if not __last: break
            __last = forced = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return b;
        self._reset(mark)
        return None;

    @memoize
    def while_stmt(self) -> Optional[ast . While]:
        # while_stmt: invalid_while_stmt | 'while' named_expression ':' block else_block?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_while_stmt = self.invalid_while_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('while')
            if not __last: break
            __last = a = self.named_expression()
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            c = self.else_block()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . While ( test = a , body = b , orelse = c or [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def for_stmt(self) -> Optional[Union [ast . For , ast . AsyncFor]]:
        # for_stmt: invalid_for_stmt | 'for' star_targets 'in' ~ star_expressions &&':' TYPE_COMMENT? block else_block? | 'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | invalid_for_target
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_for_stmt = self.invalid_for_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        cut = False
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('for')
            if not __last: break
            __last = t = self.star_targets()
            if not __last: break
            __last = literal_1 = self.expect('in')
            if not __last: break
            __last = cut = True
            if not __last: break
            __last = ex = self.star_expressions()
            if not __last: break
            __last = forced = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __last = b = self.block()
            if not __last: break
            el = self.else_block()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . For ( target = t , iter = ex , body = b , orelse = el or [] , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        if cut:
            return None;
        cut = False
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('async')
            if not __last: break
            __last = literal_1 = self.expect('for')
            if not __last: break
            __last = t = self.star_targets()
            if not __last: break
            __last = literal_2 = self.expect('in')
            if not __last: break
            __last = cut = True
            if not __last: break
            __last = ex = self.star_expressions()
            if not __last: break
            __last = literal_3 = self.expect(':')
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __last = b = self.block()
            if not __last: break
            el = self.else_block()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 5 ) , "Async for loops are" , ast . AsyncFor ( target = t , iter = ex , body = b , orelse = el or [] , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) );
        self._reset(mark)
        if cut:
            return None;
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_for_target = self.invalid_for_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def with_stmt(self) -> Optional[Union [ast . With , ast . AsyncWith]]:
        # with_stmt: invalid_with_stmt_indent | 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' TYPE_COMMENT? block | 'async' 'with' '(' ','.with_item+ ','? ')' ':' block | 'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block | invalid_with_stmt
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_with_stmt_indent = self.invalid_with_stmt_indent()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('with')
            if not __last: break
            __last = literal_1 = self.expect('(')
            if not __last: break
            __last = a = self._gather_52()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_2 = self.expect(')')
            if not __last: break
            __last = literal_3 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 9 ) , "Parenthesized with items" , ast . With ( items = a , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('with')
            if not __last: break
            __last = a = self._gather_54()
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . With ( items = a , body = b , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('async')
            if not __last: break
            __last = literal_1 = self.expect('with')
            if not __last: break
            __last = literal_2 = self.expect('(')
            if not __last: break
            __last = a = self._gather_56()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_3 = self.expect(')')
            if not __last: break
            __last = literal_4 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 9 ) , "Parenthesized with items" , ast . AsyncWith ( items = a , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('async')
            if not __last: break
            __last = literal_1 = self.expect('with')
            if not __last: break
            __last = a = self._gather_58()
            if not __last: break
            __last = literal_2 = self.expect(':')
            if not __last: break
            tc = self.type_comment()
            __last = True
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 5 ) , "Async with statements are" , ast . AsyncWith ( items = a , body = b , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_with_stmt = self.invalid_with_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def with_item(self) -> Optional[ast . withitem]:
        # with_item: expression 'as' star_target &(',' | ')' | ':') | invalid_with_item | expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = e = self.expression()
            if not __last: break
            __last = literal = self.expect('as')
            if not __last: break
            __last = t = self.star_target()
            if not __last: break
            __last = self.positive_lookahead(self._tmp_60, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . withitem ( context_expr = e , optional_vars = t );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_with_item = self.invalid_with_item()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = e = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . withitem ( context_expr = e , optional_vars = None );
        self._reset(mark)
        return None;

    @memoize
    def try_stmt(self) -> Optional[ast . Try]:
        # try_stmt: invalid_try_stmt | 'try' &&':' block finally_block | 'try' &&':' block except_block+ else_block? finally_block?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_try_stmt = self.invalid_try_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('try')
            if not __last: break
            __last = forced = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __last = f = self.finally_block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Try ( body = b , handlers = [] , orelse = [] , finalbody = f , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('try')
            if not __last: break
            __last = forced = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __last = ex = self._loop1_61()
            if not __last: break
            el = self.else_block()
            __last = True
            if not __last: break
            f = self.finally_block()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Try ( body = b , handlers = ex , orelse = el or [] , finalbody = f or [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def except_block(self) -> Optional[ast . ExceptHandler]:
        # except_block: invalid_except_stmt_indent | 'except' expression ['as' NAME] ':' block | 'except' ':' block | invalid_except_stmt
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_except_stmt_indent = self.invalid_except_stmt_indent()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('except')
            if not __last: break
            __last = e = self.expression()
            if not __last: break
            t = self._tmp_62()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . ExceptHandler ( type = e , name = t , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('except')
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = b = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . ExceptHandler ( type = None , name = None , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_except_stmt = self.invalid_except_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def finally_block(self) -> Optional[list]:
        # finally_block: invalid_finally_stmt | 'finally' &&':' block
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_finally_stmt = self.invalid_finally_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('finally')
            if not __last: break
            __last = forced = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            __last = a = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def match_stmt(self) -> Optional["ast.Match"]:
        # match_stmt: "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT | invalid_match_stmt
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect("match")
            if not __last: break
            __last = subject = self.subject_expr()
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = _indent = self.expect('INDENT')
            if not __last: break
            __last = cases = self._loop1_63()
            if not __last: break
            __last = _dedent = self.expect('DEDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Match ( subject = subject , cases = cases , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_match_stmt = self.invalid_match_stmt()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def subject_expr(self) -> Optional[Any]:
        # subject_expr: star_named_expression ',' star_named_expressions? | named_expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = value = self.star_named_expression()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            values = self.star_named_expressions()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 10 ) , "Pattern matching is" , ast . Tuple ( elts = [value] + ( values or [] ) , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = e = self.named_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . check_version ( ( 3 , 10 ) , "Pattern matching is" , e );
        self._reset(mark)
        return None;

    @memoize
    def case_block(self) -> Optional["ast.match_case"]:
        # case_block: invalid_case_block | "case" patterns guard? ':' block
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_case_block = self.invalid_case_block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect("case")
            if not __last: break
            __last = pattern = self.patterns()
            if not __last: break
            guard = self.guard()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = body = self.block()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . match_case ( pattern = pattern , guard = guard , body = body );
        self._reset(mark)
        return None;

    @memoize
    def guard(self) -> Optional[Any]:
        # guard: 'if' named_expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('if')
            if not __last: break
            __last = guard = self.named_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return guard;
        self._reset(mark)
        return None;

    @memoize
    def patterns(self) -> Optional[Any]:
        # patterns: open_sequence_pattern | pattern
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = patterns = self.open_sequence_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchSequence ( patterns = patterns , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = pattern = self.pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return pattern;
        self._reset(mark)
        return None;

    @memoize
    def pattern(self) -> Optional[Any]:
        # pattern: as_pattern | or_pattern
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = as_pattern = self.as_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return as_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = or_pattern = self.or_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return or_pattern;
        self._reset(mark)
        return None;

    @memoize
    def as_pattern(self) -> Optional["ast.MatchAs"]:
        # as_pattern: or_pattern 'as' pattern_capture_target | invalid_as_pattern
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = pattern = self.or_pattern()
            if not __last: break
            __last = literal = self.expect('as')
            if not __last: break
            __last = target = self.pattern_capture_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchAs ( pattern = pattern , name = target , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_as_pattern = self.invalid_as_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def or_pattern(self) -> Optional["ast.MatchOr"]:
        # or_pattern: '|'.closed_pattern+
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = patterns = self._gather_64()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchOr ( patterns = patterns , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if len ( patterns ) > 1 else patterns [0];
        self._reset(mark)
        return None;

    @memoize
    def closed_pattern(self) -> Optional[Any]:
        # closed_pattern: literal_pattern | capture_pattern | wildcard_pattern | value_pattern | group_pattern | sequence_pattern | mapping_pattern | class_pattern
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal_pattern = self.literal_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = capture_pattern = self.capture_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return capture_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = wildcard_pattern = self.wildcard_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return wildcard_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = value_pattern = self.value_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return value_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = group_pattern = self.group_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return group_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = sequence_pattern = self.sequence_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return sequence_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = mapping_pattern = self.mapping_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return mapping_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = class_pattern = self.class_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return class_pattern;
        self._reset(mark)
        return None;

    @memoize
    def literal_pattern(self) -> Optional[Any]:
        # literal_pattern: signed_number !('+' | '-') | complex_number | strings | 'None' | 'True' | 'False'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = value = self.signed_number()
            if not __last: break
            __last = self.negative_lookahead(self._tmp_66, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchValue ( value = value , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = value = self.complex_number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchValue ( value = value , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = value = self.strings()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchValue ( value = value , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('None')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchSingleton ( value = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('True')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchSingleton ( value = True , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('False')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchSingleton ( value = False , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def literal_expr(self) -> Optional[Any]:
        # literal_expr: signed_number !('+' | '-') | complex_number | strings | 'None' | 'True' | 'False'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = signed_number = self.signed_number()
            if not __last: break
            __last = self.negative_lookahead(self._tmp_67, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return signed_number;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = complex_number = self.complex_number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return complex_number;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = strings = self.strings()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return strings;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('None')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('True')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = True , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('False')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = False , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def complex_number(self) -> Optional[Any]:
        # complex_number: signed_real_number '+' imaginary_number | signed_real_number '-' imaginary_number
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = real = self.signed_real_number()
            if not __last: break
            __last = literal = self.expect('+')
            if not __last: break
            __last = imag = self.imaginary_number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = real , op = ast . Add ( ) , right = imag , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = real = self.signed_real_number()
            if not __last: break
            __last = literal = self.expect('-')
            if not __last: break
            __last = imag = self.imaginary_number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = real , op = ast . Sub ( ) , right = imag , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def signed_number(self) -> Optional[Any]:
        # signed_number: NUMBER | '-' NUMBER
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = ast . literal_eval ( a . string ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('-')
            if not __last: break
            __last = a = self.number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . UnaryOp ( op = ast . USub ( ) , operand = ast . Constant ( value = ast . literal_eval ( a . string ) , lineno = a . start [0] , col_offset = a . start [1] , end_lineno = a . end [0] , end_col_offset = a . end [1] ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        return None;

    @memoize
    def signed_real_number(self) -> Optional[Any]:
        # signed_real_number: real_number | '-' real_number
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = real_number = self.real_number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return real_number;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('-')
            if not __last: break
            __last = real = self.real_number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . UnaryOp ( op = ast . USub ( ) , operand = real , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def real_number(self) -> Optional[ast . Constant]:
        # real_number: NUMBER
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = real = self.number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = self . ensure_real ( real ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def imaginary_number(self) -> Optional[ast . Constant]:
        # imaginary_number: NUMBER
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = imag = self.number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = self . ensure_imaginary ( imag ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def capture_pattern(self) -> Optional[Any]:
        # capture_pattern: pattern_capture_target
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = target = self.pattern_capture_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchAs ( pattern = None , name = target , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def pattern_capture_target(self) -> Optional[str]:
        # pattern_capture_target: !"_" NAME !('.' | '(' | '=')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.negative_lookahead(self.expect, "_")
            if not __last: break
            __last = name = self.name()
            if not __last: break
            __last = self.negative_lookahead(self._tmp_68, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return name . string;
        self._reset(mark)
        return None;

    @memoize
    def wildcard_pattern(self) -> Optional["ast.MatchAs"]:
        # wildcard_pattern: "_"
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect("_")
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchAs ( pattern = None , target = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def value_pattern(self) -> Optional["ast.MatchValue"]:
        # value_pattern: attr !('.' | '(' | '=')
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = attr = self.attr()
            if not __last: break
            __last = self.negative_lookahead(self._tmp_69, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchValue ( value = attr , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize_left_rec
    def attr(self) -> Optional[ast . Attribute]:
        # attr: name_or_attr '.' NAME
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = value = self.name_or_attr()
            if not __last: break
            __last = literal = self.expect('.')
            if not __last: break
            __last = attr = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Attribute ( value = value , attr = attr . string , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @logger
    def name_or_attr(self) -> Optional[Any]:
        # name_or_attr: attr | NAME
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = attr = self.attr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return attr;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = name = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Name ( id = name . string , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def group_pattern(self) -> Optional[Any]:
        # group_pattern: '(' pattern ')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = pattern = self.pattern()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return pattern;
        self._reset(mark)
        return None;

    @memoize
    def sequence_pattern(self) -> Optional["ast.MatchSequence"]:
        # sequence_pattern: '[' maybe_sequence_pattern? ']' | '(' open_sequence_pattern? ')'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            patterns = self.maybe_sequence_pattern()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchSequence ( patterns = patterns or [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            patterns = self.open_sequence_pattern()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchSequence ( patterns = patterns or [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def open_sequence_pattern(self) -> Optional[Any]:
        # open_sequence_pattern: maybe_star_pattern ',' maybe_sequence_pattern?
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = pattern = self.maybe_star_pattern()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            patterns = self.maybe_sequence_pattern()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [pattern] + ( patterns or [] );
        self._reset(mark)
        return None;

    @memoize
    def maybe_sequence_pattern(self) -> Optional[Any]:
        # maybe_sequence_pattern: ','.maybe_star_pattern+ ','?
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = patterns = self._gather_70()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return patterns;
        self._reset(mark)
        return None;

    @memoize
    def maybe_star_pattern(self) -> Optional[Any]:
        # maybe_star_pattern: star_pattern | pattern
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_pattern = self.star_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_pattern;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = pattern = self.pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return pattern;
        self._reset(mark)
        return None;

    @memoize
    def star_pattern(self) -> Optional[Any]:
        # star_pattern: '*' pattern_capture_target | '*' wildcard_pattern
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = target = self.pattern_capture_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchStar ( name = target , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = wildcard_pattern = self.wildcard_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchStar ( target = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def mapping_pattern(self) -> Optional[Any]:
        # mapping_pattern: '{' '}' | '{' double_star_pattern ','? '}' | '{' items_pattern ',' double_star_pattern ','? '}' | '{' items_pattern ','? '}'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchMapping ( keys = [] , patterns = [] , rest = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __last = rest = self.double_star_pattern()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchMapping ( keys = [] , patterns = [] , rest = rest , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __last = items = self.items_pattern()
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = rest = self.double_star_pattern()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_2 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchMapping ( keys = [k for k , _ in items] , patterns = [p for _ , p in items] , rest = rest , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __last = items = self.items_pattern()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchMapping ( keys = [k for k , _ in items] , patterns = [p for _ , p in items] , rest = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        return None;

    @memoize
    def items_pattern(self) -> Optional[Any]:
        # items_pattern: ','.key_value_pattern+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _gather_72 = self._gather_72()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _gather_72;
        self._reset(mark)
        return None;

    @memoize
    def key_value_pattern(self) -> Optional[Any]:
        # key_value_pattern: (literal_expr | attr) ':' pattern
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = key = self._tmp_74()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = pattern = self.pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( key , pattern );
        self._reset(mark)
        return None;

    @memoize
    def double_star_pattern(self) -> Optional[Any]:
        # double_star_pattern: '**' pattern_capture_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = target = self.pattern_capture_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return target;
        self._reset(mark)
        return None;

    @memoize
    def class_pattern(self) -> Optional["ast.MatchClass"]:
        # class_pattern: name_or_attr '(' ')' | name_or_attr '(' positional_patterns ','? ')' | name_or_attr '(' keyword_patterns ','? ')' | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')' | invalid_class_pattern
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = cls = self.name_or_attr()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchClass ( cls = cls , patterns = [] , kwd_attrs = [] , kwd_patterns = [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = cls = self.name_or_attr()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            __last = patterns = self.positional_patterns()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchClass ( cls = cls , patterns = patterns , kwd_attrs = [] , kwd_patterns = [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = cls = self.name_or_attr()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            __last = keywords = self.keyword_patterns()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchClass ( cls = cls , patterns = [] , kwd_attrs = [k for k , _ in keywords] , kwd_patterns = [p for _ , p in keywords] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = cls = self.name_or_attr()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            __last = patterns = self.positional_patterns()
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = keywords = self.keyword_patterns()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_2 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . MatchClass ( cls = cls , patterns = patterns , kwd_attrs = [k for k , _ in keywords] , kwd_patterns = [p for _ , p in keywords] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_class_pattern = self.invalid_class_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def positional_patterns(self) -> Optional[Any]:
        # positional_patterns: ','.pattern+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = args = self._gather_75()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return args;
        self._reset(mark)
        return None;

    @memoize
    def keyword_patterns(self) -> Optional[Any]:
        # keyword_patterns: ','.keyword_pattern+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _gather_77 = self._gather_77()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _gather_77;
        self._reset(mark)
        return None;

    @memoize
    def keyword_pattern(self) -> Optional[Any]:
        # keyword_pattern: NAME '=' pattern
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = arg = self.name()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __last = value = self.pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( arg . string , value );
        self._reset(mark)
        return None;

    @memoize
    def expressions(self) -> Optional[Any]:
        # expressions: expression ((',' expression))+ ','? | expression ',' | expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expression()
            if not __last: break
            __last = b = self._loop1_79()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = [a] + b , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expression()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = [a] , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return expression;
        self._reset(mark)
        return None;

    @memoize
    def expression(self) -> Optional[Any]:
        # expression: invalid_expression | invalid_legacy_expression | disjunction 'if' disjunction 'else' expression | disjunction | lambdef
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_expression = self.invalid_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_legacy_expression = self.invalid_legacy_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.disjunction()
            if not __last: break
            __last = literal = self.expect('if')
            if not __last: break
            __last = b = self.disjunction()
            if not __last: break
            __last = literal_1 = self.expect('else')
            if not __last: break
            __last = c = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . IfExp ( body = a , test = b , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = disjunction = self.disjunction()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return disjunction;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambdef = self.lambdef()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambdef;
        self._reset(mark)
        return None;

    @memoize
    def yield_expr(self) -> Optional[Any]:
        # yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('yield')
            if not __last: break
            __last = literal_1 = self.expect('from')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . YieldFrom ( value = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('yield')
            if not __last: break
            a = self.star_expressions()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Yield ( value = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def star_expressions(self) -> Optional[Any]:
        # star_expressions: star_expression ((',' star_expression))+ ','? | star_expression ',' | star_expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_expression()
            if not __last: break
            __last = b = self._loop1_80()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = [a] + b , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_expression()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = [a] , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_expression = self.star_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_expression;
        self._reset(mark)
        return None;

    @memoize
    def star_expression(self) -> Optional[Any]:
        # star_expression: '*' bitwise_or | expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Starred ( value = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return expression;
        self._reset(mark)
        return None;

    @memoize
    def star_named_expressions(self) -> Optional[Any]:
        # star_named_expressions: ','.star_named_expression+ ','?
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_81()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def star_named_expression(self) -> Optional[Any]:
        # star_named_expression: '*' bitwise_or | named_expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Starred ( value = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = named_expression = self.named_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return named_expression;
        self._reset(mark)
        return None;

    @memoize
    def assignment_expression(self) -> Optional[Any]:
        # assignment_expression: NAME ':=' ~ expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        cut = False
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __last = literal = self.expect(':=')
            if not __last: break
            __last = cut = True
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 8 ) , "The ':=' operator is" , ast . NamedExpr ( target = ast . Name ( id = a . string , ctx = Store , lineno = a . start [0] , col_offset = a . start [1] , end_lineno = a . end [0] , end_col_offset = a . end [1] ) , value = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , ) );
        self._reset(mark)
        if cut:
            return None;
        return None;

    @memoize
    def named_expression(self) -> Optional[Any]:
        # named_expression: assignment_expression | invalid_named_expression | expression !':='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = assignment_expression = self.assignment_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return assignment_expression;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_named_expression = self.invalid_named_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expression()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ':=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def disjunction(self) -> Optional[Any]:
        # disjunction: conjunction (('or' conjunction))+ | conjunction
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.conjunction()
            if not __last: break
            __last = b = self._loop1_83()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BoolOp ( op = ast . Or ( ) , values = [a] + b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = conjunction = self.conjunction()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return conjunction;
        self._reset(mark)
        return None;

    @memoize
    def conjunction(self) -> Optional[Any]:
        # conjunction: inversion (('and' inversion))+ | inversion
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.inversion()
            if not __last: break
            __last = b = self._loop1_84()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BoolOp ( op = ast . And ( ) , values = [a] + b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = inversion = self.inversion()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return inversion;
        self._reset(mark)
        return None;

    @memoize
    def inversion(self) -> Optional[Any]:
        # inversion: 'not' inversion | comparison
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('not')
            if not __last: break
            __last = a = self.inversion()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . UnaryOp ( op = ast . Not ( ) , operand = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = comparison = self.comparison()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return comparison;
        self._reset(mark)
        return None;

    @memoize
    def comparison(self) -> Optional[Any]:
        # comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.bitwise_or()
            if not __last: break
            __last = b = self._loop1_85()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Compare ( left = a , ops = self . get_comparison_ops ( b ) , comparators = self . get_comparators ( b ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = bitwise_or = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return bitwise_or;
        self._reset(mark)
        return None;

    @memoize
    def compare_op_bitwise_or_pair(self) -> Optional[Any]:
        # compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = eq_bitwise_or = self.eq_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return eq_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = noteq_bitwise_or = self.noteq_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return noteq_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lte_bitwise_or = self.lte_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lte_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lt_bitwise_or = self.lt_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lt_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = gte_bitwise_or = self.gte_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return gte_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = gt_bitwise_or = self.gt_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return gt_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = notin_bitwise_or = self.notin_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return notin_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = in_bitwise_or = self.in_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return in_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = isnot_bitwise_or = self.isnot_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return isnot_bitwise_or;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = is_bitwise_or = self.is_bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return is_bitwise_or;
        self._reset(mark)
        return None;

    @memoize
    def eq_bitwise_or(self) -> Optional[Any]:
        # eq_bitwise_or: '==' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('==')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . Eq ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def noteq_bitwise_or(self) -> Optional[tuple]:
        # noteq_bitwise_or: '!=' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('!=')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . NotEq ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def lte_bitwise_or(self) -> Optional[Any]:
        # lte_bitwise_or: '<=' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('<=')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . LtE ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def lt_bitwise_or(self) -> Optional[Any]:
        # lt_bitwise_or: '<' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('<')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . Lt ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def gte_bitwise_or(self) -> Optional[Any]:
        # gte_bitwise_or: '>=' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('>=')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . GtE ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def gt_bitwise_or(self) -> Optional[Any]:
        # gt_bitwise_or: '>' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('>')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . Gt ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def notin_bitwise_or(self) -> Optional[Any]:
        # notin_bitwise_or: 'not' 'in' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('not')
            if not __last: break
            __last = literal_1 = self.expect('in')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . NotIn ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def in_bitwise_or(self) -> Optional[Any]:
        # in_bitwise_or: 'in' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('in')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . In ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def isnot_bitwise_or(self) -> Optional[Any]:
        # isnot_bitwise_or: 'is' 'not' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('is')
            if not __last: break
            __last = literal_1 = self.expect('not')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . IsNot ( ) , a );
        self._reset(mark)
        return None;

    @memoize
    def is_bitwise_or(self) -> Optional[Any]:
        # is_bitwise_or: 'is' bitwise_or
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('is')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( ast . Is ( ) , a );
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_or(self) -> Optional[Any]:
        # bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.bitwise_or()
            if not __last: break
            __last = literal = self.expect('|')
            if not __last: break
            __last = b = self.bitwise_xor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . BitOr ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = bitwise_xor = self.bitwise_xor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return bitwise_xor;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_xor(self) -> Optional[Any]:
        # bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.bitwise_xor()
            if not __last: break
            __last = literal = self.expect('^')
            if not __last: break
            __last = b = self.bitwise_and()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . BitXor ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = bitwise_and = self.bitwise_and()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return bitwise_and;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_and(self) -> Optional[Any]:
        # bitwise_and: bitwise_and '&' shift_expr | shift_expr
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.bitwise_and()
            if not __last: break
            __last = literal = self.expect('&')
            if not __last: break
            __last = b = self.shift_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . BitAnd ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = shift_expr = self.shift_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return shift_expr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def shift_expr(self) -> Optional[Any]:
        # shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.shift_expr()
            if not __last: break
            __last = literal = self.expect('<<')
            if not __last: break
            __last = b = self.sum()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . LShift ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.shift_expr()
            if not __last: break
            __last = literal = self.expect('>>')
            if not __last: break
            __last = b = self.sum()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . RShift ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = sum = self.sum()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return sum;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def sum(self) -> Optional[Any]:
        # sum: sum '+' term | sum '-' term | term
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.sum()
            if not __last: break
            __last = literal = self.expect('+')
            if not __last: break
            __last = b = self.term()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . Add ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.sum()
            if not __last: break
            __last = literal = self.expect('-')
            if not __last: break
            __last = b = self.term()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . Sub ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = term = self.term()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return term;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def term(self) -> Optional[Any]:
        # term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.term()
            if not __last: break
            __last = literal = self.expect('*')
            if not __last: break
            __last = b = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . Mult ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.term()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = b = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . Div ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.term()
            if not __last: break
            __last = literal = self.expect('//')
            if not __last: break
            __last = b = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . FloorDiv ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.term()
            if not __last: break
            __last = literal = self.expect('%')
            if not __last: break
            __last = b = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . Mod ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.term()
            if not __last: break
            __last = literal = self.expect('@')
            if not __last: break
            __last = b = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 5 ) , "The '@' operator is" , ast . BinOp ( left = a , op = ast . MatMult ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = factor = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return factor;
        self._reset(mark)
        return None;

    @memoize
    def factor(self) -> Optional[Any]:
        # factor: '+' factor | '-' factor | '~' factor | power
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('+')
            if not __last: break
            __last = a = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . UnaryOp ( op = ast . UAdd ( ) , operand = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('-')
            if not __last: break
            __last = a = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . UnaryOp ( op = ast . USub ( ) , operand = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('~')
            if not __last: break
            __last = a = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . UnaryOp ( op = ast . Invert ( ) , operand = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = power = self.power()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return power;
        self._reset(mark)
        return None;

    @memoize
    def power(self) -> Optional[Any]:
        # power: await_primary '**' factor | await_primary
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.await_primary()
            if not __last: break
            __last = literal = self.expect('**')
            if not __last: break
            __last = b = self.factor()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . BinOp ( left = a , op = ast . Pow ( ) , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = await_primary = self.await_primary()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return await_primary;
        self._reset(mark)
        return None;

    @memoize
    def await_primary(self) -> Optional[Any]:
        # await_primary: 'await' primary | primary
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('await')
            if not __last: break
            __last = a = self.primary()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return self . check_version ( ( 3 , 5 ) , "Await expressions are" , ast . Await ( a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = primary = self.primary()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return primary;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def primary(self) -> Optional[Any]:
        # primary: primary '.' NAME | primary genexp | primary '(' arguments? ')' | primary '[' slices ']' | atom
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.primary()
            if not __last: break
            __last = literal = self.expect('.')
            if not __last: break
            __last = b = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Attribute ( value = a , attr = b . string , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.primary()
            if not __last: break
            __last = b = self.genexp()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Call ( func = a , args = [b] , keywords = [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.primary()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            b = self.arguments()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Call ( func = a , args = b [0] if b else [] , keywords = b [1] if b else [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.primary()
            if not __last: break
            __last = literal = self.expect('[')
            if not __last: break
            __last = b = self.slices()
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Subscript ( value = a , slice = b , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = atom = self.atom()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return atom;
        self._reset(mark)
        return None;

    @memoize
    def slices(self) -> Optional[Any]:
        # slices: slice !',' | ','.slice+ ','?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.slice()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_86()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if sys . version_info >= ( 3 , 9 ) else ( ast . ExtSlice ( dims = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if any ( isinstance ( e , ast . Slice ) for e in a ) else ast . Index ( value = ast . Tuple ( elts = [e . value for e in a] , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) );
        self._reset(mark)
        return None;

    @memoize
    def slice(self) -> Optional[Any]:
        # slice: expression? ':' expression? [':' expression?] | named_expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            a = self.expression()
            __last = True
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            b = self.expression()
            __last = True
            if not __last: break
            c = self._tmp_88()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Slice ( lower = a , upper = b , step = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.named_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a if sys . version_info >= ( 3 , 9 ) or isinstance ( a , ast . Slice ) else ast . Index ( value = a , lineno = a . lineno , col_offset = a . col_offset , end_lineno = a . end_lineno , end_col_offset = a . end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def atom(self) -> Optional[Any]:
        # atom: NAME | 'True' | 'False' | 'None' | &STRING strings | NUMBER | &'(' (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set | dictcomp | setcomp) | '...'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Name ( id = a . string , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('True')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = True , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if sys . version_info >= ( 3 , 9 ) else ast . Constant ( value = True , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('False')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = False , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if sys . version_info >= ( 3 , 9 ) else ast . Constant ( value = False , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('None')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if sys . version_info >= ( 3 , 9 ) else ast . Constant ( value = None , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.string, )
            if not __last: break
            __last = strings = self.strings()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return strings;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.number()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = ast . literal_eval ( a . string ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if sys . version_info >= ( 3 , 9 ) else ast . Constant ( value = ast . literal_eval ( a . string ) , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, '(')
            if not __last: break
            __last = _tmp_89 = self._tmp_89()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _tmp_89;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, '[')
            if not __last: break
            __last = _tmp_90 = self._tmp_90()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _tmp_90;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.positive_lookahead(self.expect, '{')
            if not __last: break
            __last = _tmp_91 = self._tmp_91()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _tmp_91;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('...')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Constant ( value = Ellipsis , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if sys . version_info >= ( 3 , 9 ) else ast . Constant ( value = Ellipsis , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def group(self) -> Optional[Any]:
        # group: '(' (yield_expr | named_expression) ')' | invalid_group
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self._tmp_92()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_group = self.invalid_group()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def lambdef(self) -> Optional[Any]:
        # lambdef: 'lambda' lambda_params? ':' expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('lambda')
            if not __last: break
            a = self.lambda_params()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Lambda ( args = a or self . make_arguments ( None , [] , None , [] , ( None , [] , None ) ) , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def lambda_params(self) -> Optional[Any]:
        # lambda_params: invalid_lambda_parameters | lambda_parameters
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_lambda_parameters = self.invalid_lambda_parameters()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambda_parameters = self.lambda_parameters()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambda_parameters;
        self._reset(mark)
        return None;

    @memoize
    def lambda_parameters(self) -> Optional[ast . arguments]:
        # lambda_parameters: lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc? | lambda_slash_with_default lambda_param_with_default* lambda_star_etc? | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc? | lambda_param_with_default+ lambda_star_etc? | lambda_star_etc
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_slash_no_default()
            if not __last: break
            b = self._loop0_93()
            __last = True
            if not __last: break
            c = self._loop0_94()
            __last = True
            if not __last: break
            d = self.lambda_star_etc()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . make_arguments ( a , [] , b , c , d );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_slash_with_default()
            if not __last: break
            b = self._loop0_95()
            __last = True
            if not __last: break
            c = self.lambda_star_etc()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . make_arguments ( None , a , None , b , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_96()
            if not __last: break
            b = self._loop0_97()
            __last = True
            if not __last: break
            c = self.lambda_star_etc()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . make_arguments ( None , [] , a , b , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_98()
            if not __last: break
            b = self.lambda_star_etc()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . make_arguments ( None , [] , None , a , b );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_star_etc()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . make_arguments ( None , [] , None , [] , a );
        self._reset(mark)
        return None;

    @memoize
    def lambda_slash_no_default(self) -> Optional[List [Tuple [ast . arg , None]]]:
        # lambda_slash_no_default: lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_99()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [( p , None ) for p in a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_100()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = self.positive_lookahead(self.expect, ':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [( p , None ) for p in a];
        self._reset(mark)
        return None;

    @memoize
    def lambda_slash_with_default(self) -> Optional[List [Tuple [ast . arg , Any]]]:
        # lambda_slash_with_default: lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            a = self._loop0_101()
            __last = True
            if not __last: break
            __last = b = self._loop1_102()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( [( p , None ) for p in a] if a else [] ) + b;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            a = self._loop0_103()
            __last = True
            if not __last: break
            __last = b = self._loop1_104()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = self.positive_lookahead(self.expect, ':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( [( p , None ) for p in a] if a else [] ) + b;
        self._reset(mark)
        return None;

    @memoize
    def lambda_star_etc(self) -> Optional[Tuple [Optional [ast . arg] , List [Tuple [ast . arg , Any]] , Optional [ast . arg]]]:
        # lambda_star_etc: invalid_lambda_star_etc | '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds? | '*' ',' lambda_param_maybe_default+ lambda_kwds? | lambda_kwds
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_lambda_star_etc = self.invalid_lambda_star_etc()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = a = self.lambda_param_no_default()
            if not __last: break
            b = self._loop0_105()
            __last = True
            if not __last: break
            c = self.lambda_kwds()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( a , b , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = b = self._loop1_106()
            if not __last: break
            c = self.lambda_kwds()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( None , b , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_kwds()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( None , [] , a );
        self._reset(mark)
        return None;

    @memoize
    def lambda_kwds(self) -> Optional[ast . arg]:
        # lambda_kwds: invalid_lambda_kwds | '**' lambda_param_no_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_lambda_kwds = self.invalid_lambda_kwds()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = a = self.lambda_param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def lambda_param_no_default(self) -> Optional[ast . arg]:
        # lambda_param_no_default: lambda_param ',' | lambda_param &':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_param()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_param()
            if not __last: break
            __last = self.positive_lookahead(self.expect, ':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def lambda_param_with_default(self) -> Optional[Tuple [ast . arg , Any]]:
        # lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_param()
            if not __last: break
            __last = c = self.default()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( a , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_param()
            if not __last: break
            __last = c = self.default()
            if not __last: break
            __last = self.positive_lookahead(self.expect, ':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( a , c );
        self._reset(mark)
        return None;

    @memoize
    def lambda_param_maybe_default(self) -> Optional[Tuple [ast . arg , Any]]:
        # lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_param()
            if not __last: break
            c = self.default()
            __last = True
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( a , c );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_param()
            if not __last: break
            c = self.default()
            __last = True
            if not __last: break
            __last = self.positive_lookahead(self.expect, ':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( a , c );
        self._reset(mark)
        return None;

    @memoize
    def lambda_param(self) -> Optional[ast . arg]:
        # lambda_param: NAME
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . arg ( arg = a . string , annotation = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if sys . version_info >= ( 3 , 9 ) else ast . arg ( arg = a . string , annotation = None , type_comment = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def strings(self) -> Optional[ast . Str]:
        # strings: STRING+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_107()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . generate_ast_for_string ( a );
        self._reset(mark)
        return None;

    @memoize
    def list(self) -> Optional[ast . List]:
        # list: '[' star_named_expressions? ']'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            a = self.star_named_expressions()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . List ( elts = a or [] , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def tuple(self) -> Optional[ast . Tuple]:
        # tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            a = self._tmp_108()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = a or [] , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def set(self) -> Optional[ast . Set]:
        # set: '{' star_named_expressions '}'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __last = a = self.star_named_expressions()
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Set ( elts = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def dict(self) -> Optional[ast . Dict]:
        # dict: '{' double_starred_kvpairs? '}' | '{' invalid_double_starred_kvpairs '}'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            a = self.double_starred_kvpairs()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Dict ( keys = [kv [0] for kv in ( a or [] )] , values = [kv [1] for kv in ( a or [] )] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = literal = self.expect('{')
            if not __last: break
            __last = invalid_double_starred_kvpairs = self.invalid_double_starred_kvpairs()
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def double_starred_kvpairs(self) -> Optional[list]:
        # double_starred_kvpairs: ','.double_starred_kvpair+ ','?
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_109()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def double_starred_kvpair(self) -> Optional[Any]:
        # double_starred_kvpair: '**' bitwise_or | kvpair
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( None , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = kvpair = self.kvpair()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return kvpair;
        self._reset(mark)
        return None;

    @memoize
    def kvpair(self) -> Optional[tuple]:
        # kvpair: expression ':' expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expression()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( a , b );
        self._reset(mark)
        return None;

    @memoize
    def for_if_clauses(self) -> Optional[List [ast . comprehension]]:
        # for_if_clauses: for_if_clause+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_111()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def for_if_clause(self) -> Optional[ast . comprehension]:
        # for_if_clause: 'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | invalid_for_target
        mark = self._mark()
        cut = False
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('async')
            if not __last: break
            __last = literal_1 = self.expect('for')
            if not __last: break
            __last = a = self.star_targets()
            if not __last: break
            __last = literal_2 = self.expect('in')
            if not __last: break
            __last = cut = True
            if not __last: break
            __last = b = self.disjunction()
            if not __last: break
            c = self._loop0_112()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . check_version ( ( 3 , 6 ) , "Async comprehensions are" , ast . comprehension ( target = a , iter = b , ifs = c , is_async = 1 ) );
        self._reset(mark)
        if cut:
            return None;
        cut = False
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('for')
            if not __last: break
            __last = a = self.star_targets()
            if not __last: break
            __last = literal_1 = self.expect('in')
            if not __last: break
            __last = cut = True
            if not __last: break
            __last = b = self.disjunction()
            if not __last: break
            c = self._loop0_113()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ast . comprehension ( target = a , iter = b , ifs = c , is_async = 0 );
        self._reset(mark)
        if cut:
            return None;
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_for_target = self.invalid_for_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def listcomp(self) -> Optional[ast . ListComp]:
        # listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            __last = a = self.named_expression()
            if not __last: break
            __last = b = self.for_if_clauses()
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . ListComp ( elt = a , generators = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_comprehension = self.invalid_comprehension()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def setcomp(self) -> Optional[ast . SetComp]:
        # setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __last = a = self.named_expression()
            if not __last: break
            __last = b = self.for_if_clauses()
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . SetComp ( elt = a , generators = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_comprehension = self.invalid_comprehension()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def genexp(self) -> Optional[ast . GeneratorExp]:
        # genexp: '(' (assignment_expression | expression !':=') for_if_clauses ')' | invalid_comprehension
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self._tmp_114()
            if not __last: break
            __last = b = self.for_if_clauses()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . GeneratorExp ( elt = a , generators = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_comprehension = self.invalid_comprehension()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def dictcomp(self) -> Optional[ast . DictComp]:
        # dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __last = a = self.kvpair()
            if not __last: break
            __last = b = self.for_if_clauses()
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . DictComp ( key = a [0] , value = a [1] , generators = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_dict_comprehension = self.invalid_dict_comprehension()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def arguments(self) -> Optional[Tuple [list , list]]:
        # arguments: args ','? &')' | invalid_arguments
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.args()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = self.positive_lookahead(self.expect, ')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_arguments = self.invalid_arguments()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def args(self) -> Optional[Tuple [list , list]]:
        # args: ','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs] | kwargs
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_115()
            if not __last: break
            b = self._tmp_117()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( a + ( [e for e in b if isinstance ( e , ast . Starred )] if b else [] ) , ( [e for e in b if not isinstance ( e , ast . Starred )] if b else [] ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.kwargs()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( [e for e in a if isinstance ( e , ast . Starred )] , [e for e in a if not isinstance ( e , ast . Starred )] );
        self._reset(mark)
        return None;

    @memoize
    def kwargs(self) -> Optional[list]:
        # kwargs: ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_118()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = b = self._gather_120()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a + b;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _gather_122 = self._gather_122()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _gather_122;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _gather_124 = self._gather_124()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _gather_124;
        self._reset(mark)
        return None;

    @memoize
    def starred_expression(self) -> Optional[Any]:
        # starred_expression: '*' expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Starred ( value = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def kwarg_or_starred(self) -> Optional[Any]:
        # kwarg_or_starred: invalid_kwarg | NAME '=' expression | starred_expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_kwarg = self.invalid_kwarg()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . keyword ( arg = a . string , value = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.starred_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def kwarg_or_double_starred(self) -> Optional[Any]:
        # kwarg_or_double_starred: invalid_kwarg | NAME '=' expression | '**' expression
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_kwarg = self.invalid_kwarg()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . keyword ( arg = a . string , value = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . keyword ( arg = None , value = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def star_targets(self) -> Optional[Any]:
        # star_targets: star_target !',' | star_target ((',' star_target))* ','?
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_target()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_target()
            if not __last: break
            b = self._loop0_126()
            __last = True
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = [a] + b , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def star_targets_list_seq(self) -> Optional[list]:
        # star_targets_list_seq: ','.star_target+ ','?
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_127()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def star_targets_tuple_seq(self) -> Optional[list]:
        # star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_target()
            if not __last: break
            __last = b = self._loop1_129()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a] + b;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_target()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a];
        self._reset(mark)
        return None;

    @memoize
    def star_target(self) -> Optional[Any]:
        # star_target: '*' (!'*' star_target) | target_with_star_atom
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = a = self._tmp_130()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Starred ( value = self . set_expr_context ( a , Store ) , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = target_with_star_atom = self.target_with_star_atom()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return target_with_star_atom;
        self._reset(mark)
        return None;

    @memoize
    def target_with_star_atom(self) -> Optional[Any]:
        # target_with_star_atom: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('.')
            if not __last: break
            __last = b = self.name()
            if not __last: break
            __last = self.negative_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Attribute ( value = a , attr = b . string , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('[')
            if not __last: break
            __last = b = self.slices()
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __last = self.negative_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Subscript ( value = a , slice = b , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_atom = self.star_atom()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_atom;
        self._reset(mark)
        return None;

    @memoize
    def star_atom(self) -> Optional[Any]:
        # star_atom: NAME | '(' target_with_star_atom ')' | '(' star_targets_tuple_seq? ')' | '[' star_targets_list_seq? ']'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Name ( id = a . string , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self.target_with_star_atom()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . set_expr_context ( a , Store );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            a = self.star_targets_tuple_seq()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = a , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            a = self.star_targets_list_seq()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . List ( elts = a , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def single_target(self) -> Optional[Any]:
        # single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = single_subscript_attribute_target = self.single_subscript_attribute_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return single_subscript_attribute_target;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Name ( id = a . string , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self.single_target()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def single_subscript_attribute_target(self) -> Optional[Any]:
        # single_subscript_attribute_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('.')
            if not __last: break
            __last = b = self.name()
            if not __last: break
            __last = self.negative_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Attribute ( value = a , attr = b . string , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('[')
            if not __last: break
            __last = b = self.slices()
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __last = self.negative_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Subscript ( value = a , slice = b , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize_left_rec
    def t_primary(self) -> Optional[Any]:
        # t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' arguments? ')' &t_lookahead | atom &t_lookahead
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('.')
            if not __last: break
            __last = b = self.name()
            if not __last: break
            __last = self.positive_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Attribute ( value = a , attr = b . string , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('[')
            if not __last: break
            __last = b = self.slices()
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __last = self.positive_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Subscript ( value = a , slice = b , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = b = self.genexp()
            if not __last: break
            __last = self.positive_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Call ( func = a , args = [b] , keywords = [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            b = self.arguments()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __last = self.positive_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Call ( func = a , args = b [0] if b else [] , keywords = b [1] if b else [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.atom()
            if not __last: break
            __last = self.positive_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def t_lookahead(self) -> Optional[Any]:
        # t_lookahead: '(' | '[' | '.'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('.')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def del_targets(self) -> Optional[Any]:
        # del_targets: ','.del_target+ ','?
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_131()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def del_target(self) -> Optional[Any]:
        # del_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('.')
            if not __last: break
            __last = b = self.name()
            if not __last: break
            __last = self.negative_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Attribute ( value = a , attr = b . string , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.t_primary()
            if not __last: break
            __last = literal = self.expect('[')
            if not __last: break
            __last = b = self.slices()
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __last = self.negative_lookahead(self.t_lookahead, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Subscript ( value = a , slice = b , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = del_t_atom = self.del_t_atom()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return del_t_atom;
        self._reset(mark)
        return None;

    @memoize
    def del_t_atom(self) -> Optional[Any]:
        # del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Name ( id = a . string , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self.del_target()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . set_expr_context ( a , Del );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            a = self.del_targets()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . Tuple ( elts = a , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            a = self.del_targets()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(']')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return ast . List ( elts = a , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        return None;

    @memoize
    def type_expressions(self) -> Optional[list]:
        # type_expressions: ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_133()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = literal_1 = self.expect('*')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __last = literal_2 = self.expect(',')
            if not __last: break
            __last = literal_3 = self.expect('**')
            if not __last: break
            __last = c = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a + [b , c];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_135()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = literal_1 = self.expect('*')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a + [b];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_137()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = literal_1 = self.expect('**')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a + [b];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = literal_2 = self.expect('**')
            if not __last: break
            __last = b = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a , b];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._gather_139()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def func_type_comment(self) -> Optional[Any]:
        # func_type_comment: NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | invalid_double_type_comments | TYPE_COMMENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = t = self.type_comment()
            if not __last: break
            __last = self.positive_lookahead(self._tmp_141, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return t . string;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = invalid_double_type_comments = self.invalid_double_type_comments()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = type_comment = self.type_comment()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return type_comment;
        self._reset(mark)
        return None;

    @memoize
    def invalid_arguments(self) -> Optional[NoReturn]:
        # invalid_arguments: args ',' '*' | expression for_if_clauses ',' [args | expression for_if_clauses] | NAME '=' expression for_if_clauses | args for_if_clauses | args ',' expression for_if_clauses | args ',' args
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.args()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = literal_1 = self.expect('*')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "iterable argument unpacking follows keyword argument unpacking" , a [1] [- 1] if a [1] else a [0] [- 1] , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expression()
            if not __last: break
            __last = b = self.for_if_clauses()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            opt = self._tmp_142()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "Generator expression must be parenthesized" , a , ( b [- 1] . ifs [- 1] if b [- 1] . ifs else b [- 1] . iter ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __last = b = self.expect('=')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            __last = for_if_clauses = self.for_if_clauses()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "invalid syntax. Maybe you meant '==' or ':=' instead of '='?" , a , b );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.args()
            if not __last: break
            __last = b = self.for_if_clauses()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "Generator expression must be parenthesized" , a [0] [- 1] , ( b [- 1] . ifs [- 1] if b [- 1] . ifs else b [- 1] . iter ) , ) if len ( a [0] ) > 1 else None;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = args = self.args()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __last = b = self.for_if_clauses()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "Generator expression must be parenthesized" , a , ( b [- 1] . ifs [- 1] if b [- 1] . ifs else b [- 1] . iter ) , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.args()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = args = self.args()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "positional argument follows keyword argument unpacking" if a [1] [- 1] . arg is None else "positional argument follows keyword argument" , );
        self._reset(mark)
        return None;

    @memoize
    def invalid_kwarg(self) -> Optional[NoReturn]:
        # invalid_kwarg: ('True' | 'False' | 'None') '=' | NAME '=' expression for_if_clauses | !(NAME '=') expression '='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._tmp_143()
            if not __last: break
            __last = b = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( f"cannot assign to {a.string}" , a , b );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __last = b = self.expect('=')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            __last = for_if_clauses = self.for_if_clauses()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "invalid syntax. Maybe you meant '==' or ':=' instead of '='?" , a , b );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.negative_lookahead(self._tmp_144, )
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __last = b = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "expression cannot contain assignment, perhaps you meant \"==\"?" , a , b , );
        self._reset(mark)
        return None;

    @memoize
    def expression_without_invalid(self) -> Optional[ast . AST]:
        # expression_without_invalid: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
        _prev_call_invalid = self.call_invalid_rules
        self.call_invalid_rules = False
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.disjunction()
            if not __last: break
            __last = literal = self.expect('if')
            if not __last: break
            __last = b = self.disjunction()
            if not __last: break
            __last = literal_1 = self.expect('else')
            if not __last: break
            __last = c = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            self.call_invalid_rules = _prev_call_invalid
            return ast . IfExp ( body = b , test = a , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = disjunction = self.disjunction()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            self.call_invalid_rules = _prev_call_invalid
            return disjunction;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambdef = self.lambdef()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            self.call_invalid_rules = _prev_call_invalid
            return lambdef;
        self._reset(mark)
        self.call_invalid_rules = _prev_call_invalid
        return None;

    @memoize
    def invalid_legacy_expression(self) -> Optional[Any]:
        # invalid_legacy_expression: NAME !'(' expression_without_invalid
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __last = self.negative_lookahead(self.expect, '(')
            if not __last: break
            __last = b = self.expression_without_invalid()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( f"Missing parentheses in call to '{a.string}' . Did you mean {a.string}(...)?" , a , b , ) if a . string in ( "exec" , "print" ) else None;
        self._reset(mark)
        return None;

    @memoize
    def invalid_expression(self) -> Optional[NoReturn]:
        # invalid_expression: !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid | disjunction 'if' disjunction !('else' | ':')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.negative_lookahead(self._tmp_145, )
            if not __last: break
            __last = a = self.disjunction()
            if not __last: break
            __last = b = self.expression_without_invalid()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( self . raise_syntax_error_known_range ( "invalid syntax. Perhaps you forgot a comma?" , a , b ) if not isinstance ( a , ast . Name ) or a . id not in ( "print" , "exec" ) else None );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.disjunction()
            if not __last: break
            __last = literal = self.expect('if')
            if not __last: break
            __last = b = self.disjunction()
            if not __last: break
            __last = self.negative_lookahead(self._tmp_146, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "expected 'else' after 'if' expression" , a , b );
        self._reset(mark)
        return None;

    @memoize
    def invalid_named_expression(self) -> Optional[NoReturn]:
        # invalid_named_expression: expression ':=' expression | NAME '=' bitwise_or !('=' | ':=') | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expression()
            if not __last: break
            __last = literal = self.expect(':=')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( f"cannot use assignment expressions with {self.get_expr_name(a)}" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.name()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __last = b = self.bitwise_or()
            if not __last: break
            __last = self.negative_lookahead(self._tmp_147, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( None if self . in_recursive_rule else self . raise_syntax_error_known_range ( "invalid syntax. Maybe you meant '==' or ':=' instead of '='?" , a , b ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.negative_lookahead(self._tmp_148, )
            if not __last: break
            __last = a = self.bitwise_or()
            if not __last: break
            __last = b = self.expect('=')
            if not __last: break
            __last = bitwise_or = self.bitwise_or()
            if not __last: break
            __last = self.negative_lookahead(self._tmp_149, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return ( None if self . in_recursive_rule else self . raise_syntax_error_known_location ( f"cannot assign to {self.get_expr_name(a)} here. Maybe you meant '==' instead of '='?" , a ) );
        self._reset(mark)
        return None;

    @memoize
    def invalid_assignment(self) -> Optional[NoReturn]:
        # invalid_assignment: invalid_ann_assign_target ':' expression | star_named_expression ',' star_named_expressions* ':' expression | expression ':' expression | ((star_targets '='))* star_expressions '=' | ((star_targets '='))* yield_expr '=' | star_expressions augassign (yield_expr | star_expressions)
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = a = self.invalid_ann_assign_target()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( f"only single target (not {self.get_expr_name(a)}) can be annotated" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_named_expression()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            _loop0_150 = self._loop0_150()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "only single target (not tuple) can be annotated" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expression()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "illegal target for annotation" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            _loop0_151 = self._loop0_151()
            __last = True
            if not __last: break
            __last = a = self.star_expressions()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_invalid_target ( Target . STAR_TARGETS , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            _loop0_152 = self._loop0_152()
            __last = True
            if not __last: break
            __last = a = self.yield_expr()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "assignment to yield expression not possible" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.star_expressions()
            if not __last: break
            __last = augassign = self.augassign()
            if not __last: break
            __last = _tmp_153 = self._tmp_153()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( f"'{self.get_expr_name(a)}' is an illegal expression for augmented assignment" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_ann_assign_target(self) -> Optional[ast . AST]:
        # invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.list()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.tuple()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self.invalid_ann_assign_target()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def invalid_del_stmt(self) -> Optional[NoReturn]:
        # invalid_del_stmt: 'del' star_expressions
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('del')
            if not __last: break
            __last = a = self.star_expressions()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_invalid_target ( Target . DEL_TARGETS , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_block(self) -> Optional[NoReturn]:
        # invalid_block: NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( "expected an indented block" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_comprehension(self) -> Optional[NoReturn]:
        # invalid_comprehension: ('[' | '(' | '{') starred_expression for_if_clauses | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses | ('[' | '{') star_named_expression ',' for_if_clauses
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _tmp_154 = self._tmp_154()
            if not __last: break
            __last = a = self.starred_expression()
            if not __last: break
            __last = for_if_clauses = self.for_if_clauses()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "iterable unpacking cannot be used in comprehension" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _tmp_155 = self._tmp_155()
            if not __last: break
            __last = a = self.star_named_expression()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = b = self.star_named_expressions()
            if not __last: break
            __last = for_if_clauses = self.for_if_clauses()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "did you forget parentheses around the comprehension target?" , a , b [- 1] );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _tmp_156 = self._tmp_156()
            if not __last: break
            __last = a = self.star_named_expression()
            if not __last: break
            __last = b = self.expect(',')
            if not __last: break
            __last = for_if_clauses = self.for_if_clauses()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "did you forget parentheses around the comprehension target?" , a , b );
        self._reset(mark)
        return None;

    @memoize
    def invalid_dict_comprehension(self) -> Optional[NoReturn]:
        # invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __last = a = self.expect('**')
            if not __last: break
            __last = bitwise_or = self.bitwise_or()
            if not __last: break
            __last = for_if_clauses = self.for_if_clauses()
            if not __last: break
            __last = literal_1 = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "dict unpacking cannot be used in dict comprehension" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_parameters(self) -> Optional[NoReturn]:
        # invalid_parameters: param_no_default* invalid_parameters_helper param_no_default | param_no_default* '(' param_no_default+ ','? ')' | "/" ',' | (slash_no_default | slash_with_default) param_maybe_default* '/' | [(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/' | param_maybe_default+ '/' '*'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            _loop0_157 = self._loop0_157()
            __last = True
            if not __last: break
            __last = invalid_parameters_helper = self.invalid_parameters_helper()
            if not __last: break
            __last = a = self.param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "non-default argument follows default argument" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            _loop0_158 = self._loop0_158()
            __last = True
            if not __last: break
            __last = a = self.expect('(')
            if not __last: break
            __last = _loop1_159 = self._loop1_159()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = b = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "Function parameters cannot be parenthesized" , a , b );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect("/")
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "at least one argument must precede /" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _tmp_160 = self._tmp_160()
            if not __last: break
            _loop0_161 = self._loop0_161()
            __last = True
            if not __last: break
            __last = a = self.expect('/')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "/ may appear only once" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self._tmp_162()
            __last = True
            if not __last: break
            _loop0_163 = self._loop0_163()
            __last = True
            if not __last: break
            __last = literal = self.expect('*')
            if not __last: break
            __last = _tmp_164 = self._tmp_164()
            if not __last: break
            _loop0_165 = self._loop0_165()
            __last = True
            if not __last: break
            __last = a = self.expect('/')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "/ must be ahead of *" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _loop1_166 = self._loop1_166()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = a = self.expect('*')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "expected comma between / and *" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_default(self) -> Optional[Any]:
        # invalid_default: '=' &(')' | ',')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('=')
            if not __last: break
            __last = self.positive_lookahead(self._tmp_167, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "expected default value expression" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_star_etc(self) -> Optional[Any]:
        # invalid_star_etc: '*' (')' | ',' (')' | '**')) | '*' ',' TYPE_COMMENT | '*' param '=' | '*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('*')
            if not __last: break
            __last = _tmp_168 = self._tmp_168()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "named arguments must follow bare *" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = type_comment = self.type_comment()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "bare * has associated type comment" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = param = self.param()
            if not __last: break
            __last = a = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "var-positional argument cannot have default value" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = _tmp_169 = self._tmp_169()
            if not __last: break
            _loop0_170 = self._loop0_170()
            __last = True
            if not __last: break
            __last = a = self.expect('*')
            if not __last: break
            __last = _tmp_171 = self._tmp_171()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "* argument may appear only once" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_kwds(self) -> Optional[Any]:
        # invalid_kwds: '**' param '=' | '**' param ',' param | '**' param ',' ('*' | '**' | '/')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = param = self.param()
            if not __last: break
            __last = a = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "var-keyword argument cannot have default value" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = param = self.param()
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = a = self.param()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "arguments cannot follow var-keyword argument" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = param = self.param()
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = a = self._tmp_172()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "arguments cannot follow var-keyword argument" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_parameters_helper(self) -> Optional[Any]:
        # invalid_parameters_helper: slash_with_default | param_with_default+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.slash_with_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_173()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def invalid_lambda_parameters(self) -> Optional[NoReturn]:
        # invalid_lambda_parameters: lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default | lambda_param_no_default* '(' ','.lambda_param+ ','? ')' | "/" ',' | (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/' | [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/' | lambda_param_maybe_default+ '/' '*'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            _loop0_174 = self._loop0_174()
            __last = True
            if not __last: break
            __last = invalid_lambda_parameters_helper = self.invalid_lambda_parameters_helper()
            if not __last: break
            __last = a = self.lambda_param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "non-default argument follows default argument" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            _loop0_175 = self._loop0_175()
            __last = True
            if not __last: break
            __last = a = self.expect('(')
            if not __last: break
            __last = _gather_176 = self._gather_176()
            if not __last: break
            opt = self.expect(',')
            __last = True
            if not __last: break
            __last = b = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "Lambda expression parameters cannot be parenthesized" , a , b );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect("/")
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "at least one argument must precede /" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _tmp_178 = self._tmp_178()
            if not __last: break
            _loop0_179 = self._loop0_179()
            __last = True
            if not __last: break
            __last = a = self.expect('/')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "/ may appear only once" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self._tmp_180()
            __last = True
            if not __last: break
            _loop0_181 = self._loop0_181()
            __last = True
            if not __last: break
            __last = literal = self.expect('*')
            if not __last: break
            __last = _tmp_182 = self._tmp_182()
            if not __last: break
            _loop0_183 = self._loop0_183()
            __last = True
            if not __last: break
            __last = a = self.expect('/')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "/ must be ahead of *" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _loop1_184 = self._loop1_184()
            if not __last: break
            __last = literal = self.expect('/')
            if not __last: break
            __last = a = self.expect('*')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "expected comma between / and *" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_lambda_parameters_helper(self) -> Optional[NoReturn]:
        # invalid_lambda_parameters_helper: lambda_slash_with_default | lambda_param_with_default+
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.lambda_slash_with_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [a];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self._loop1_185()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def invalid_lambda_star_etc(self) -> Optional[NoReturn]:
        # invalid_lambda_star_etc: '*' (':' | ',' (':' | '**')) | '*' lambda_param '=' | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = _tmp_186 = self._tmp_186()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "named arguments must follow bare *" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = lambda_param = self.lambda_param()
            if not __last: break
            __last = a = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "var-positional argument cannot have default value" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __last = _tmp_187 = self._tmp_187()
            if not __last: break
            _loop0_188 = self._loop0_188()
            __last = True
            if not __last: break
            __last = a = self.expect('*')
            if not __last: break
            __last = _tmp_189 = self._tmp_189()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "* argument may appear only once" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_lambda_kwds(self) -> Optional[Any]:
        # invalid_lambda_kwds: '**' lambda_param '=' | '**' lambda_param ',' lambda_param | '**' lambda_param ',' ('*' | '**' | '/')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = lambda_param = self.lambda_param()
            if not __last: break
            __last = a = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "var-keyword argument cannot have default value" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = lambda_param = self.lambda_param()
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = a = self.lambda_param()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "arguments cannot follow var-keyword argument" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __last = lambda_param = self.lambda_param()
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = a = self._tmp_190()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "arguments cannot follow var-keyword argument" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_double_type_comments(self) -> Optional[NoReturn]:
        # invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = type_comment = self.type_comment()
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = type_comment_1 = self.type_comment()
            if not __last: break
            __last = _newline_1 = self.expect('NEWLINE')
            if not __last: break
            __last = _indent = self.expect('INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "Cannot have two type comments on def" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_with_item(self) -> Optional[NoReturn]:
        # invalid_with_item: expression 'as' expression &(',' | ')' | ':')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __last = literal = self.expect('as')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __last = self.positive_lookahead(self._tmp_191, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_invalid_target ( Target . STAR_TARGETS , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_for_target(self) -> Optional[NoReturn]:
        # invalid_for_target: 'async'? 'for' star_expressions
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self.expect('async')
            __last = True
            if not __last: break
            __last = literal = self.expect('for')
            if not __last: break
            __last = a = self.star_expressions()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_invalid_target ( Target . FOR_TARGETS , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_group(self) -> Optional[NoReturn]:
        # invalid_group: '(' starred_expression ')' | '(' '**' expression ')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self.starred_expression()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "cannot use starred expression here" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self.expect('**')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "cannot use double starred expression here" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_import_from_targets(self) -> Optional[NoReturn]:
        # invalid_import_from_targets: import_from_as_names ',' NEWLINE
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = import_from_as_names = self.import_from_as_names()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "trailing comma not allowed without surrounding parentheses" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_with_stmt(self) -> Optional[None]:
        # invalid_with_stmt: 'async'? 'with' ','.(expression ['as' star_target])+ &&':' | 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' &&':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self.expect('async')
            __last = True
            if not __last: break
            __last = literal = self.expect('with')
            if not __last: break
            __last = _gather_192 = self._gather_192()
            if not __last: break
            __last = forced = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self.expect('async')
            __last = True
            if not __last: break
            __last = literal = self.expect('with')
            if not __last: break
            __last = literal_1 = self.expect('(')
            if not __last: break
            __last = _gather_194 = self._gather_194()
            if not __last: break
            opt_1 = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_2 = self.expect(')')
            if not __last: break
            __last = forced = self.expect_forced(self.expect(':'), "':'")
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        return None;

    @memoize
    def invalid_with_stmt_indent(self) -> Optional[NoReturn]:
        # invalid_with_stmt_indent: 'async'? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT | 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self.expect('async')
            __last = True
            if not __last: break
            __last = a = self.expect('with')
            if not __last: break
            __last = _gather_196 = self._gather_196()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'with' statement on line {a.start[0]}" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self.expect('async')
            __last = True
            if not __last: break
            __last = a = self.expect('with')
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            __last = _gather_198 = self._gather_198()
            if not __last: break
            opt_1 = self.expect(',')
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __last = literal_2 = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'with' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_try_stmt(self) -> Optional[NoReturn]:
        # invalid_try_stmt: 'try' ':' NEWLINE !INDENT | 'try' ':' block !('except' | 'finally')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('try')
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'try' statement on line {a.start[0]}" , );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('try')
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = block = self.block()
            if not __last: break
            __last = self.negative_lookahead(self._tmp_200, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "expected 'except' or 'finally' block" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_except_stmt(self) -> Optional[None]:
        # invalid_except_stmt: 'except' expression ',' expressions ['as' NAME] ':' | 'except' expression ['as' NAME] NEWLINE | 'except' NEWLINE
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('except')
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __last = literal_1 = self.expect(',')
            if not __last: break
            __last = expressions = self.expressions()
            if not __last: break
            opt = self._tmp_201()
            __last = True
            if not __last: break
            __last = literal_2 = self.expect(':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_starting_from ( "multiple exception types must be parenthesized" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('except')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            opt = self._tmp_202()
            __last = True
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "expected ':'" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('except')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "expected ':'" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_finally_stmt(self) -> Optional[NoReturn]:
        # invalid_finally_stmt: 'finally' ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('finally')
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'finally' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_except_stmt_indent(self) -> Optional[NoReturn]:
        # invalid_except_stmt_indent: 'except' expression ['as' NAME] ':' NEWLINE !INDENT | 'except' ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('except')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            opt = self._tmp_203()
            __last = True
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'except' statement on line {a.start[0]}" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('except')
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'except' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_match_stmt(self) -> Optional[NoReturn]:
        # invalid_match_stmt: "match" subject_expr !':' | "match" subject_expr ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect("match")
            if not __last: break
            __last = subject_expr = self.subject_expr()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . check_version ( ( 3 , 10 ) , "Pattern matching is" , self . raise_syntax_error ( "expected ':'" ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect("match")
            if not __last: break
            __last = subject = self.subject_expr()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . check_version ( ( 3 , 10 ) , "Pattern matching is" , self . raise_indentation_error ( f"expected an indented block after 'match' statement on line {a.start[0]}" ) );
        self._reset(mark)
        return None;

    @memoize
    def invalid_case_block(self) -> Optional[NoReturn]:
        # invalid_case_block: "case" patterns guard? !':' | "case" patterns guard? ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect("case")
            if not __last: break
            __last = patterns = self.patterns()
            if not __last: break
            opt = self.guard()
            __last = True
            if not __last: break
            __last = self.negative_lookahead(self.expect, ':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "expected ':'" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect("case")
            if not __last: break
            __last = patterns = self.patterns()
            if not __last: break
            opt = self.guard()
            __last = True
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'case' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_as_pattern(self) -> Optional[NoReturn]:
        # invalid_as_pattern: or_pattern 'as' "_" | or_pattern 'as' !NAME expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = or_pattern = self.or_pattern()
            if not __last: break
            __last = literal = self.expect('as')
            if not __last: break
            __last = a = self.expect("_")
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "cannot use '_' as a target" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = or_pattern = self.or_pattern()
            if not __last: break
            __last = literal = self.expect('as')
            if not __last: break
            __last = self.negative_lookahead(self.name, )
            if not __last: break
            __last = a = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "invalid pattern target" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_class_pattern(self) -> Optional[NoReturn]:
        # invalid_class_pattern: name_or_attr '(' invalid_class_argument_pattern
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = name_or_attr = self.name_or_attr()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            __last = a = self.invalid_class_argument_pattern()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_range ( "positional patterns follow keyword patterns" , a [0] , a [- 1] );
        self._reset(mark)
        return None;

    @memoize
    def invalid_class_argument_pattern(self) -> Optional[list]:
        # invalid_class_argument_pattern: [positional_patterns ','] keyword_patterns ',' positional_patterns
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self._tmp_204()
            __last = True
            if not __last: break
            __last = keyword_patterns = self.keyword_patterns()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = a = self.positional_patterns()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return a;
        self._reset(mark)
        return None;

    @memoize
    def invalid_if_stmt(self) -> Optional[NoReturn]:
        # invalid_if_stmt: 'if' named_expression NEWLINE | 'if' named_expression ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('if')
            if not __last: break
            __last = named_expression = self.named_expression()
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "expected ':'" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('if')
            if not __last: break
            __last = a_1 = self.named_expression()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'if' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_elif_stmt(self) -> Optional[NoReturn]:
        # invalid_elif_stmt: 'elif' named_expression NEWLINE | 'elif' named_expression ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('elif')
            if not __last: break
            __last = named_expression = self.named_expression()
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "expected ':'" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('elif')
            if not __last: break
            __last = named_expression = self.named_expression()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'elif' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_else_stmt(self) -> Optional[NoReturn]:
        # invalid_else_stmt: 'else' ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('else')
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'else' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_while_stmt(self) -> Optional[NoReturn]:
        # invalid_while_stmt: 'while' named_expression NEWLINE | 'while' named_expression ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('while')
            if not __last: break
            __last = named_expression = self.named_expression()
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error ( "expected ':'" );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('while')
            if not __last: break
            __last = named_expression = self.named_expression()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'while' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_for_stmt(self) -> Optional[NoReturn]:
        # invalid_for_stmt: 'async'? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self.expect('async')
            __last = True
            if not __last: break
            __last = a = self.expect('for')
            if not __last: break
            __last = star_targets = self.star_targets()
            if not __last: break
            __last = literal = self.expect('in')
            if not __last: break
            __last = star_expressions = self.star_expressions()
            if not __last: break
            __last = literal_1 = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after 'for' statement on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_def_raw(self) -> Optional[NoReturn]:
        # invalid_def_raw: 'async'? 'def' NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            opt = self.expect('async')
            __last = True
            if not __last: break
            __last = a = self.expect('def')
            if not __last: break
            __last = name = self.name()
            if not __last: break
            __last = literal = self.expect('(')
            if not __last: break
            opt_1 = self.params()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            opt_2 = self._tmp_205()
            __last = True
            if not __last: break
            __last = literal_2 = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after function definition on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_class_def_raw(self) -> Optional[NoReturn]:
        # invalid_class_def_raw: 'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expect('class')
            if not __last: break
            __last = name = self.name()
            if not __last: break
            opt = self._tmp_206()
            __last = True
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = self.negative_lookahead(self.expect, 'INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_indentation_error ( f"expected an indented block after class definition on line {a.start[0]}" );
        self._reset(mark)
        return None;

    @memoize
    def invalid_double_starred_kvpairs(self) -> Optional[None]:
        # invalid_double_starred_kvpairs: ','.double_starred_kvpair+ ',' invalid_kvpair | expression ':' '*' bitwise_or | expression ':' &('}' | ',')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            if not self.call_invalid_rules: break
            __last = _gather_207 = self._gather_207()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __last = invalid_kvpair = self.invalid_kvpair()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return None  # pragma: no cover;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = a = self.expect('*')
            if not __last: break
            __last = bitwise_or = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_starting_from ( "cannot use a starred expression in a dictionary value" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __last = a = self.expect(':')
            if not __last: break
            __last = self.positive_lookahead(self._tmp_209, )
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "expression expected after dictionary key and ':'" , a );
        self._reset(mark)
        return None;

    @memoize
    def invalid_kvpair(self) -> Optional[None]:
        # invalid_kvpair: expression !(':') | expression ':' '*' bitwise_or | expression ':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = a = self.expression()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_raw_syntax_error ( "':' expected after dictionary key" , ( a . lineno , a . col_offset ) , ( a . end_lineno , a . end_col_offset ) );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __last = literal = self.expect(':')
            if not __last: break
            __last = a = self.expect('*')
            if not __last: break
            __last = bitwise_or = self.bitwise_or()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_starting_from ( "cannot use a starred expression in a dictionary value" , a );
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __last = a = self.expect(':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return self . raise_syntax_error_known_location ( "expression expected after dictionary key and ':'" , a );
        self._reset(mark)
        return None;

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: NEWLINE
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _newline = self.expect('NEWLINE')
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_newline)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_2(self) -> Optional[Any]:
        # _loop0_2: NEWLINE
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _newline = self.expect('NEWLINE')
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_newline)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_3(self) -> Optional[Any]:
        # _loop1_3: statement
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = statement = self.statement()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_5(self) -> Optional[Any]:
        # _loop0_5: ';' simple_stmt
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(';')
                if not __last: break
                __last = elem = self.simple_stmt()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_4(self) -> Optional[Any]:
        # _gather_4: simple_stmt _loop0_5
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.simple_stmt()
            if __last is None: break
            __last = seq = self._loop0_5()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_6(self) -> Optional[Any]:
        # _tmp_6: 'import' | 'from'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('import')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('from')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_7(self) -> Optional[Any]:
        # _tmp_7: 'def' | '@' | 'async'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('def')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('@')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('async')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_8(self) -> Optional[Any]:
        # _tmp_8: 'class' | '@'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('class')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('@')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_9(self) -> Optional[Any]:
        # _tmp_9: 'with' | 'async'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('with')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('async')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_10(self) -> Optional[Any]:
        # _tmp_10: 'for' | 'async'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('for')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('async')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_11(self) -> Optional[Any]:
        # _tmp_11: '=' annotated_rhs
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('=')
            if not __last: break
            __last = d = self.annotated_rhs()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return d;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_12(self) -> Optional[Any]:
        # _tmp_12: '(' single_target ')' | single_subscript_attribute_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __last = b = self.single_target()
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return b;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = single_subscript_attribute_target = self.single_subscript_attribute_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return single_subscript_attribute_target;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_13(self) -> Optional[Any]:
        # _tmp_13: '=' annotated_rhs
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('=')
            if not __last: break
            __last = d = self.annotated_rhs()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return d;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_14(self) -> Optional[Any]:
        # _loop1_14: (star_targets '=')
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_210 = self._tmp_210()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_210)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_15(self) -> Optional[Any]:
        # _tmp_15: yield_expr | star_expressions
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = yield_expr = self.yield_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return yield_expr;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_expressions = self.star_expressions()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_expressions;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_16(self) -> Optional[Any]:
        # _tmp_16: yield_expr | star_expressions
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = yield_expr = self.yield_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return yield_expr;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_expressions = self.star_expressions()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_expressions;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_17(self) -> Optional[Any]:
        # _tmp_17: 'from' expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('from')
            if not __last: break
            __last = z = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_19(self) -> Optional[Any]:
        # _loop0_19: ',' NAME
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.name()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_18(self) -> Optional[Any]:
        # _gather_18: NAME _loop0_19
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.name()
            if __last is None: break
            __last = seq = self._loop0_19()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_21(self) -> Optional[Any]:
        # _loop0_21: ',' NAME
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.name()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_20(self) -> Optional[Any]:
        # _gather_20: NAME _loop0_21
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.name()
            if __last is None: break
            __last = seq = self._loop0_21()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_22(self) -> Optional[Any]:
        # _tmp_22: ';' | NEWLINE
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(';')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _newline;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_23(self) -> Optional[Any]:
        # _tmp_23: ',' expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __last = z = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_24(self) -> Optional[Any]:
        # _loop0_24: ('.' | '...')
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_211 = self._tmp_211()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_211)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_25(self) -> Optional[Any]:
        # _loop1_25: ('.' | '...')
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_212 = self._tmp_212()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_212)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_27(self) -> Optional[Any]:
        # _loop0_27: ',' import_from_as_name
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.import_from_as_name()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_26(self) -> Optional[Any]:
        # _gather_26: import_from_as_name _loop0_27
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.import_from_as_name()
            if __last is None: break
            __last = seq = self._loop0_27()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_28(self) -> Optional[Any]:
        # _tmp_28: 'as' NAME
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = z = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z . string;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_30(self) -> Optional[Any]:
        # _loop0_30: ',' dotted_as_name
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.dotted_as_name()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_29(self) -> Optional[Any]:
        # _gather_29: dotted_as_name _loop0_30
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.dotted_as_name()
            if __last is None: break
            __last = seq = self._loop0_30()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_31(self) -> Optional[Any]:
        # _tmp_31: 'as' NAME
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = z = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z . string;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_32(self) -> Optional[Any]:
        # _loop1_32: decorator
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = decorator = self.decorator()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(decorator)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_33(self) -> Optional[Any]:
        # _tmp_33: '@' dec_maybe_call NEWLINE
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('@')
            if not __last: break
            __last = f = self.dec_maybe_call()
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return f;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_34(self) -> Optional[Any]:
        # _tmp_34: '@' named_expression NEWLINE
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('@')
            if not __last: break
            __last = f = self.named_expression()
            if not __last: break
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return f;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_35(self) -> Optional[Any]:
        # _tmp_35: '(' arguments? ')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            z = self.arguments()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_36(self) -> Optional[Any]:
        # _tmp_36: '->' expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('->')
            if not __last: break
            __last = z = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_37(self) -> Optional[Any]:
        # _tmp_37: '->' expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('->')
            if not __last: break
            __last = z = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_38(self) -> Optional[Any]:
        # _loop0_38: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_39(self) -> Optional[Any]:
        # _loop0_39: param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_with_default = self.param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_40(self) -> Optional[Any]:
        # _loop0_40: param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_with_default = self.param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_41(self) -> Optional[Any]:
        # _loop1_41: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_42(self) -> Optional[Any]:
        # _loop0_42: param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_with_default = self.param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_43(self) -> Optional[Any]:
        # _loop1_43: param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_with_default = self.param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_44(self) -> Optional[Any]:
        # _loop1_44: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_45(self) -> Optional[Any]:
        # _loop1_45: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_46(self) -> Optional[Any]:
        # _loop0_46: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_47(self) -> Optional[Any]:
        # _loop1_47: param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_with_default = self.param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_48(self) -> Optional[Any]:
        # _loop0_48: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_49(self) -> Optional[Any]:
        # _loop1_49: param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_with_default = self.param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_50(self) -> Optional[Any]:
        # _loop0_50: param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_maybe_default = self.param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_51(self) -> Optional[Any]:
        # _loop1_51: param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_maybe_default = self.param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_53(self) -> Optional[Any]:
        # _loop0_53: ',' with_item
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.with_item()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_52(self) -> Optional[Any]:
        # _gather_52: with_item _loop0_53
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.with_item()
            if __last is None: break
            __last = seq = self._loop0_53()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_55(self) -> Optional[Any]:
        # _loop0_55: ',' with_item
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.with_item()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_54(self) -> Optional[Any]:
        # _gather_54: with_item _loop0_55
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.with_item()
            if __last is None: break
            __last = seq = self._loop0_55()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_57(self) -> Optional[Any]:
        # _loop0_57: ',' with_item
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.with_item()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_56(self) -> Optional[Any]:
        # _gather_56: with_item _loop0_57
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.with_item()
            if __last is None: break
            __last = seq = self._loop0_57()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_59(self) -> Optional[Any]:
        # _loop0_59: ',' with_item
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.with_item()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_58(self) -> Optional[Any]:
        # _gather_58: with_item _loop0_59
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.with_item()
            if __last is None: break
            __last = seq = self._loop0_59()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_60(self) -> Optional[Any]:
        # _tmp_60: ',' | ')' | ':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_61(self) -> Optional[Any]:
        # _loop1_61: except_block
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = except_block = self.except_block()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(except_block)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_62(self) -> Optional[Any]:
        # _tmp_62: 'as' NAME
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = z = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z . string;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_63(self) -> Optional[Any]:
        # _loop1_63: case_block
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = case_block = self.case_block()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(case_block)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_65(self) -> Optional[Any]:
        # _loop0_65: '|' closed_pattern
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect('|')
                if not __last: break
                __last = elem = self.closed_pattern()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_64(self) -> Optional[Any]:
        # _gather_64: closed_pattern _loop0_65
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.closed_pattern()
            if __last is None: break
            __last = seq = self._loop0_65()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_66(self) -> Optional[Any]:
        # _tmp_66: '+' | '-'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('+')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('-')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_67(self) -> Optional[Any]:
        # _tmp_67: '+' | '-'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('+')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('-')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_68(self) -> Optional[Any]:
        # _tmp_68: '.' | '(' | '='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('.')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_69(self) -> Optional[Any]:
        # _tmp_69: '.' | '(' | '='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('.')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_71(self) -> Optional[Any]:
        # _loop0_71: ',' maybe_star_pattern
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.maybe_star_pattern()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_70(self) -> Optional[Any]:
        # _gather_70: maybe_star_pattern _loop0_71
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.maybe_star_pattern()
            if __last is None: break
            __last = seq = self._loop0_71()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_73(self) -> Optional[Any]:
        # _loop0_73: ',' key_value_pattern
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.key_value_pattern()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_72(self) -> Optional[Any]:
        # _gather_72: key_value_pattern _loop0_73
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.key_value_pattern()
            if __last is None: break
            __last = seq = self._loop0_73()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_74(self) -> Optional[Any]:
        # _tmp_74: literal_expr | attr
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal_expr = self.literal_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal_expr;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = attr = self.attr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return attr;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_76(self) -> Optional[Any]:
        # _loop0_76: ',' pattern
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.pattern()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_75(self) -> Optional[Any]:
        # _gather_75: pattern _loop0_76
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.pattern()
            if __last is None: break
            __last = seq = self._loop0_76()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_78(self) -> Optional[Any]:
        # _loop0_78: ',' keyword_pattern
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.keyword_pattern()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_77(self) -> Optional[Any]:
        # _gather_77: keyword_pattern _loop0_78
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.keyword_pattern()
            if __last is None: break
            __last = seq = self._loop0_78()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_79(self) -> Optional[Any]:
        # _loop1_79: (',' expression)
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_213 = self._tmp_213()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_213)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_80(self) -> Optional[Any]:
        # _loop1_80: (',' star_expression)
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_214 = self._tmp_214()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_214)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_82(self) -> Optional[Any]:
        # _loop0_82: ',' star_named_expression
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.star_named_expression()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_81(self) -> Optional[Any]:
        # _gather_81: star_named_expression _loop0_82
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.star_named_expression()
            if __last is None: break
            __last = seq = self._loop0_82()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_83(self) -> Optional[Any]:
        # _loop1_83: ('or' conjunction)
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_215 = self._tmp_215()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_215)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_84(self) -> Optional[Any]:
        # _loop1_84: ('and' inversion)
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_216 = self._tmp_216()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_216)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_85(self) -> Optional[Any]:
        # _loop1_85: compare_op_bitwise_or_pair
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = compare_op_bitwise_or_pair = self.compare_op_bitwise_or_pair()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(compare_op_bitwise_or_pair)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_87(self) -> Optional[Any]:
        # _loop0_87: ',' slice
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.slice()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_86(self) -> Optional[Any]:
        # _gather_86: slice _loop0_87
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.slice()
            if __last is None: break
            __last = seq = self._loop0_87()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_88(self) -> Optional[Any]:
        # _tmp_88: ':' expression?
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':')
            if not __last: break
            d = self.expression()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return d;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_89(self) -> Optional[Any]:
        # _tmp_89: tuple | group | genexp
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = tuple = self.tuple()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return tuple;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = group = self.group()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return group;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = genexp = self.genexp()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return genexp;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_90(self) -> Optional[Any]:
        # _tmp_90: list | listcomp
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = list = self.list()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return list;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = listcomp = self.listcomp()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return listcomp;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_91(self) -> Optional[Any]:
        # _tmp_91: dict | set | dictcomp | setcomp
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = dict = self.dict()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return dict;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = set = self.set()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return set;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = dictcomp = self.dictcomp()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return dictcomp;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = setcomp = self.setcomp()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return setcomp;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_92(self) -> Optional[Any]:
        # _tmp_92: yield_expr | named_expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = yield_expr = self.yield_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return yield_expr;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = named_expression = self.named_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return named_expression;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_93(self) -> Optional[Any]:
        # _loop0_93: lambda_param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_no_default = self.lambda_param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_94(self) -> Optional[Any]:
        # _loop0_94: lambda_param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_with_default = self.lambda_param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_95(self) -> Optional[Any]:
        # _loop0_95: lambda_param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_with_default = self.lambda_param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_96(self) -> Optional[Any]:
        # _loop1_96: lambda_param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_no_default = self.lambda_param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_97(self) -> Optional[Any]:
        # _loop0_97: lambda_param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_with_default = self.lambda_param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_98(self) -> Optional[Any]:
        # _loop1_98: lambda_param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_with_default = self.lambda_param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_99(self) -> Optional[Any]:
        # _loop1_99: lambda_param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_no_default = self.lambda_param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_100(self) -> Optional[Any]:
        # _loop1_100: lambda_param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_no_default = self.lambda_param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_101(self) -> Optional[Any]:
        # _loop0_101: lambda_param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_no_default = self.lambda_param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_102(self) -> Optional[Any]:
        # _loop1_102: lambda_param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_with_default = self.lambda_param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_103(self) -> Optional[Any]:
        # _loop0_103: lambda_param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_no_default = self.lambda_param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_104(self) -> Optional[Any]:
        # _loop1_104: lambda_param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_with_default = self.lambda_param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_105(self) -> Optional[Any]:
        # _loop0_105: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_maybe_default = self.lambda_param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_106(self) -> Optional[Any]:
        # _loop1_106: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_maybe_default = self.lambda_param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_107(self) -> Optional[Any]:
        # _loop1_107: STRING
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = string = self.string()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(string)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_108(self) -> Optional[Any]:
        # _tmp_108: star_named_expression ',' star_named_expressions?
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = y = self.star_named_expression()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            z = self.star_named_expressions()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [y] + ( z or [] );
        self._reset(mark)
        return None;

    @memoize
    def _loop0_110(self) -> Optional[Any]:
        # _loop0_110: ',' double_starred_kvpair
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.double_starred_kvpair()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_109(self) -> Optional[Any]:
        # _gather_109: double_starred_kvpair _loop0_110
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.double_starred_kvpair()
            if __last is None: break
            __last = seq = self._loop0_110()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_111(self) -> Optional[Any]:
        # _loop1_111: for_if_clause
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = for_if_clause = self.for_if_clause()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(for_if_clause)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_112(self) -> Optional[Any]:
        # _loop0_112: ('if' disjunction)
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_217 = self._tmp_217()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_217)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_113(self) -> Optional[Any]:
        # _loop0_113: ('if' disjunction)
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_218 = self._tmp_218()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_218)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_114(self) -> Optional[Any]:
        # _tmp_114: assignment_expression | expression !':='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = assignment_expression = self.assignment_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return assignment_expression;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ':=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return expression;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_116(self) -> Optional[Any]:
        # _loop0_116: ',' (starred_expression | (assignment_expression | expression !':=') !'=')
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self._tmp_219()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_115(self) -> Optional[Any]:
        # _gather_115: (starred_expression | (assignment_expression | expression !':=') !'=') _loop0_116
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self._tmp_219()
            if __last is None: break
            __last = seq = self._loop0_116()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_117(self) -> Optional[Any]:
        # _tmp_117: ',' kwargs
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __last = k = self.kwargs()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return k;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_119(self) -> Optional[Any]:
        # _loop0_119: ',' kwarg_or_starred
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.kwarg_or_starred()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_118(self) -> Optional[Any]:
        # _gather_118: kwarg_or_starred _loop0_119
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.kwarg_or_starred()
            if __last is None: break
            __last = seq = self._loop0_119()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_121(self) -> Optional[Any]:
        # _loop0_121: ',' kwarg_or_double_starred
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.kwarg_or_double_starred()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_120(self) -> Optional[Any]:
        # _gather_120: kwarg_or_double_starred _loop0_121
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.kwarg_or_double_starred()
            if __last is None: break
            __last = seq = self._loop0_121()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_123(self) -> Optional[Any]:
        # _loop0_123: ',' kwarg_or_starred
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.kwarg_or_starred()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_122(self) -> Optional[Any]:
        # _gather_122: kwarg_or_starred _loop0_123
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.kwarg_or_starred()
            if __last is None: break
            __last = seq = self._loop0_123()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_125(self) -> Optional[Any]:
        # _loop0_125: ',' kwarg_or_double_starred
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.kwarg_or_double_starred()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_124(self) -> Optional[Any]:
        # _gather_124: kwarg_or_double_starred _loop0_125
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.kwarg_or_double_starred()
            if __last is None: break
            __last = seq = self._loop0_125()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_126(self) -> Optional[Any]:
        # _loop0_126: (',' star_target)
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_220 = self._tmp_220()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_220)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_128(self) -> Optional[Any]:
        # _loop0_128: ',' star_target
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.star_target()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_127(self) -> Optional[Any]:
        # _gather_127: star_target _loop0_128
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.star_target()
            if __last is None: break
            __last = seq = self._loop0_128()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_129(self) -> Optional[Any]:
        # _loop1_129: (',' star_target)
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_221 = self._tmp_221()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_221)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_130(self) -> Optional[Any]:
        # _tmp_130: !'*' star_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = self.negative_lookahead(self.expect, '*')
            if not __last: break
            __last = star_target = self.star_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_target;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_132(self) -> Optional[Any]:
        # _loop0_132: ',' del_target
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.del_target()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_131(self) -> Optional[Any]:
        # _gather_131: del_target _loop0_132
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.del_target()
            if __last is None: break
            __last = seq = self._loop0_132()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_134(self) -> Optional[Any]:
        # _loop0_134: ',' expression
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.expression()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_133(self) -> Optional[Any]:
        # _gather_133: expression _loop0_134
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.expression()
            if __last is None: break
            __last = seq = self._loop0_134()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_136(self) -> Optional[Any]:
        # _loop0_136: ',' expression
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.expression()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_135(self) -> Optional[Any]:
        # _gather_135: expression _loop0_136
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.expression()
            if __last is None: break
            __last = seq = self._loop0_136()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_138(self) -> Optional[Any]:
        # _loop0_138: ',' expression
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.expression()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_137(self) -> Optional[Any]:
        # _gather_137: expression _loop0_138
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.expression()
            if __last is None: break
            __last = seq = self._loop0_138()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_140(self) -> Optional[Any]:
        # _loop0_140: ',' expression
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.expression()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_139(self) -> Optional[Any]:
        # _gather_139: expression _loop0_140
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.expression()
            if __last is None: break
            __last = seq = self._loop0_140()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_141(self) -> Optional[Any]:
        # _tmp_141: NEWLINE INDENT
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _newline = self.expect('NEWLINE')
            if not __last: break
            __last = _indent = self.expect('INDENT')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [_newline, _indent];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_142(self) -> Optional[Any]:
        # _tmp_142: args | expression for_if_clauses
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = args = self.args()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return args;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __last = for_if_clauses = self.for_if_clauses()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [expression, for_if_clauses];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_143(self) -> Optional[Any]:
        # _tmp_143: 'True' | 'False' | 'None'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('True')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('False')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('None')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_144(self) -> Optional[Any]:
        # _tmp_144: NAME '='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = name = self.name()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [name, literal];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_145(self) -> Optional[Any]:
        # _tmp_145: NAME STRING | SOFT_KEYWORD
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = name = self.name()
            if not __last: break
            __last = string = self.string()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [name, string];
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = soft_keyword = self.soft_keyword()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return soft_keyword;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_146(self) -> Optional[Any]:
        # _tmp_146: 'else' | ':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('else')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_147(self) -> Optional[Any]:
        # _tmp_147: '=' | ':='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_148(self) -> Optional[Any]:
        # _tmp_148: list | tuple | genexp | 'True' | 'None' | 'False'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = list = self.list()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return list;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = tuple = self.tuple()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return tuple;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = genexp = self.genexp()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return genexp;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('True')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('None')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('False')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_149(self) -> Optional[Any]:
        # _tmp_149: '=' | ':='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_150(self) -> Optional[Any]:
        # _loop0_150: star_named_expressions
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = star_named_expressions = self.star_named_expressions()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(star_named_expressions)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_151(self) -> Optional[Any]:
        # _loop0_151: (star_targets '=')
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_222 = self._tmp_222()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_222)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_152(self) -> Optional[Any]:
        # _loop0_152: (star_targets '=')
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = _tmp_223 = self._tmp_223()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(_tmp_223)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_153(self) -> Optional[Any]:
        # _tmp_153: yield_expr | star_expressions
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = yield_expr = self.yield_expr()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return yield_expr;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_expressions = self.star_expressions()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return star_expressions;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_154(self) -> Optional[Any]:
        # _tmp_154: '[' | '(' | '{'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_155(self) -> Optional[Any]:
        # _tmp_155: '[' | '{'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_156(self) -> Optional[Any]:
        # _tmp_156: '[' | '{'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('[')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('{')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_157(self) -> Optional[Any]:
        # _loop0_157: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_158(self) -> Optional[Any]:
        # _loop0_158: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_159(self) -> Optional[Any]:
        # _loop1_159: param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_no_default = self.param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_160(self) -> Optional[Any]:
        # _tmp_160: slash_no_default | slash_with_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = slash_no_default = self.slash_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return slash_no_default;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = slash_with_default = self.slash_with_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return slash_with_default;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_161(self) -> Optional[Any]:
        # _loop0_161: param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_maybe_default = self.param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_162(self) -> Optional[Any]:
        # _tmp_162: slash_no_default | slash_with_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = slash_no_default = self.slash_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return slash_no_default;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = slash_with_default = self.slash_with_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return slash_with_default;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_163(self) -> Optional[Any]:
        # _loop0_163: param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_maybe_default = self.param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_164(self) -> Optional[Any]:
        # _tmp_164: ',' | param_no_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = param_no_default = self.param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return param_no_default;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_165(self) -> Optional[Any]:
        # _loop0_165: param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_maybe_default = self.param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_166(self) -> Optional[Any]:
        # _loop1_166: param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_maybe_default = self.param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_167(self) -> Optional[Any]:
        # _tmp_167: ')' | ','
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_168(self) -> Optional[Any]:
        # _tmp_168: ')' | ',' (')' | '**')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __last = _tmp_224 = self._tmp_224()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, _tmp_224];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_169(self) -> Optional[Any]:
        # _tmp_169: param_no_default | ','
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = param_no_default = self.param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return param_no_default;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_170(self) -> Optional[Any]:
        # _loop0_170: param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_maybe_default = self.param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_171(self) -> Optional[Any]:
        # _tmp_171: param_no_default | ','
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = param_no_default = self.param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return param_no_default;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_172(self) -> Optional[Any]:
        # _tmp_172: '*' | '**' | '/'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('/')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_173(self) -> Optional[Any]:
        # _loop1_173: param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = param_with_default = self.param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_174(self) -> Optional[Any]:
        # _loop0_174: lambda_param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_no_default = self.lambda_param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_175(self) -> Optional[Any]:
        # _loop0_175: lambda_param_no_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_no_default = self.lambda_param_no_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_177(self) -> Optional[Any]:
        # _loop0_177: ',' lambda_param
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.lambda_param()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_176(self) -> Optional[Any]:
        # _gather_176: lambda_param _loop0_177
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.lambda_param()
            if __last is None: break
            __last = seq = self._loop0_177()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_178(self) -> Optional[Any]:
        # _tmp_178: lambda_slash_no_default | lambda_slash_with_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambda_slash_no_default = self.lambda_slash_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambda_slash_no_default;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambda_slash_with_default = self.lambda_slash_with_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambda_slash_with_default;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_179(self) -> Optional[Any]:
        # _loop0_179: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_maybe_default = self.lambda_param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_180(self) -> Optional[Any]:
        # _tmp_180: lambda_slash_no_default | lambda_slash_with_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambda_slash_no_default = self.lambda_slash_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambda_slash_no_default;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambda_slash_with_default = self.lambda_slash_with_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambda_slash_with_default;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_181(self) -> Optional[Any]:
        # _loop0_181: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_maybe_default = self.lambda_param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_182(self) -> Optional[Any]:
        # _tmp_182: ',' | lambda_param_no_default
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambda_param_no_default = self.lambda_param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambda_param_no_default;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_183(self) -> Optional[Any]:
        # _loop0_183: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_maybe_default = self.lambda_param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_184(self) -> Optional[Any]:
        # _loop1_184: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_maybe_default = self.lambda_param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_185(self) -> Optional[Any]:
        # _loop1_185: lambda_param_with_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_with_default = self.lambda_param_with_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_186(self) -> Optional[Any]:
        # _tmp_186: ':' | ',' (':' | '**')
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __last = _tmp_225 = self._tmp_225()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, _tmp_225];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_187(self) -> Optional[Any]:
        # _tmp_187: lambda_param_no_default | ','
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambda_param_no_default = self.lambda_param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambda_param_no_default;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_188(self) -> Optional[Any]:
        # _loop0_188: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = lambda_param_maybe_default = self.lambda_param_maybe_default()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_189(self) -> Optional[Any]:
        # _tmp_189: lambda_param_no_default | ','
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = lambda_param_no_default = self.lambda_param_no_default()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return lambda_param_no_default;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_190(self) -> Optional[Any]:
        # _tmp_190: '*' | '**' | '/'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('*')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('/')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_191(self) -> Optional[Any]:
        # _tmp_191: ',' | ')' | ':'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_193(self) -> Optional[Any]:
        # _loop0_193: ',' (expression ['as' star_target])
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self._tmp_226()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_192(self) -> Optional[Any]:
        # _gather_192: (expression ['as' star_target]) _loop0_193
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self._tmp_226()
            if __last is None: break
            __last = seq = self._loop0_193()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_195(self) -> Optional[Any]:
        # _loop0_195: ',' (expressions ['as' star_target])
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self._tmp_227()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_194(self) -> Optional[Any]:
        # _gather_194: (expressions ['as' star_target]) _loop0_195
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self._tmp_227()
            if __last is None: break
            __last = seq = self._loop0_195()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_197(self) -> Optional[Any]:
        # _loop0_197: ',' (expression ['as' star_target])
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self._tmp_228()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_196(self) -> Optional[Any]:
        # _gather_196: (expression ['as' star_target]) _loop0_197
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self._tmp_228()
            if __last is None: break
            __last = seq = self._loop0_197()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_199(self) -> Optional[Any]:
        # _loop0_199: ',' (expressions ['as' star_target])
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self._tmp_229()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_198(self) -> Optional[Any]:
        # _gather_198: (expressions ['as' star_target]) _loop0_199
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self._tmp_229()
            if __last is None: break
            __last = seq = self._loop0_199()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_200(self) -> Optional[Any]:
        # _tmp_200: 'except' | 'finally'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('except')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('finally')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_201(self) -> Optional[Any]:
        # _tmp_201: 'as' NAME
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = name = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, name];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_202(self) -> Optional[Any]:
        # _tmp_202: 'as' NAME
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = name = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, name];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_203(self) -> Optional[Any]:
        # _tmp_203: 'as' NAME
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = name = self.name()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, name];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_204(self) -> Optional[Any]:
        # _tmp_204: positional_patterns ','
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = positional_patterns = self.positional_patterns()
            if not __last: break
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [positional_patterns, literal];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_205(self) -> Optional[Any]:
        # _tmp_205: '->' expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('->')
            if not __last: break
            __last = expression = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, expression];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_206(self) -> Optional[Any]:
        # _tmp_206: '(' arguments? ')'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('(')
            if not __last: break
            opt = self.arguments()
            __last = True
            if not __last: break
            __last = literal_1 = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, opt, literal_1];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_208(self) -> Optional[Any]:
        # _loop0_208: ',' double_starred_kvpair
        mark = self._mark()
        children = []
        while 1:
            __true_result = False
            while 1:  # for early false result as in the 'A and B'
                __last = literal = self.expect(',')
                if not __last: break
                __last = elem = self.double_starred_kvpair()
                if not __last: break
                __true_result = True
                break
            if not __true_result: break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_207(self) -> Optional[Any]:
        # _gather_207: double_starred_kvpair _loop0_208
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = elem = self.double_starred_kvpair()
            if __last is None: break
            __last = seq = self._loop0_208()
            if __last is None: break
            __true_result = True
            break
        if __true_result:
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_209(self) -> Optional[Any]:
        # _tmp_209: '}' | ','
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('}')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_210(self) -> Optional[Any]:
        # _tmp_210: star_targets '='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = z = self.star_targets()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_211(self) -> Optional[Any]:
        # _tmp_211: '.' | '...'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('.')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('...')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_212(self) -> Optional[Any]:
        # _tmp_212: '.' | '...'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('.')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('...')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_213(self) -> Optional[Any]:
        # _tmp_213: ',' expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __last = c = self.expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_214(self) -> Optional[Any]:
        # _tmp_214: ',' star_expression
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __last = c = self.star_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_215(self) -> Optional[Any]:
        # _tmp_215: 'or' conjunction
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('or')
            if not __last: break
            __last = c = self.conjunction()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_216(self) -> Optional[Any]:
        # _tmp_216: 'and' inversion
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('and')
            if not __last: break
            __last = c = self.inversion()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_217(self) -> Optional[Any]:
        # _tmp_217: 'if' disjunction
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('if')
            if not __last: break
            __last = z = self.disjunction()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_218(self) -> Optional[Any]:
        # _tmp_218: 'if' disjunction
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('if')
            if not __last: break
            __last = z = self.disjunction()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_219(self) -> Optional[Any]:
        # _tmp_219: starred_expression | (assignment_expression | expression !':=') !'='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = starred_expression = self.starred_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return starred_expression;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = _tmp_230 = self._tmp_230()
            if not __last: break
            __last = self.negative_lookahead(self.expect, '=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return _tmp_230;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_220(self) -> Optional[Any]:
        # _tmp_220: ',' star_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __last = c = self.star_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_221(self) -> Optional[Any]:
        # _tmp_221: ',' star_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(',')
            if not __last: break
            __last = c = self.star_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_222(self) -> Optional[Any]:
        # _tmp_222: star_targets '='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_targets = self.star_targets()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [star_targets, literal];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_223(self) -> Optional[Any]:
        # _tmp_223: star_targets '='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = star_targets = self.star_targets()
            if not __last: break
            __last = literal = self.expect('=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [star_targets, literal];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_224(self) -> Optional[Any]:
        # _tmp_224: ')' | '**'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(')')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_225(self) -> Optional[Any]:
        # _tmp_225: ':' | '**'
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect(':')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('**')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_226(self) -> Optional[Any]:
        # _tmp_226: expression ['as' star_target]
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            opt = self._tmp_231()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [expression, opt];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_227(self) -> Optional[Any]:
        # _tmp_227: expressions ['as' star_target]
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expressions = self.expressions()
            if not __last: break
            opt = self._tmp_232()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [expressions, opt];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_228(self) -> Optional[Any]:
        # _tmp_228: expression ['as' star_target]
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            opt = self._tmp_233()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [expression, opt];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_229(self) -> Optional[Any]:
        # _tmp_229: expressions ['as' star_target]
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expressions = self.expressions()
            if not __last: break
            opt = self._tmp_234()
            __last = True
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [expressions, opt];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_230(self) -> Optional[Any]:
        # _tmp_230: assignment_expression | expression !':='
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = assignment_expression = self.assignment_expression()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return assignment_expression;
        self._reset(mark)
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = expression = self.expression()
            if not __last: break
            __last = self.negative_lookahead(self.expect, ':=')
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return expression;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_231(self) -> Optional[Any]:
        # _tmp_231: 'as' star_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = star_target = self.star_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, star_target];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_232(self) -> Optional[Any]:
        # _tmp_232: 'as' star_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = star_target = self.star_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, star_target];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_233(self) -> Optional[Any]:
        # _tmp_233: 'as' star_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = star_target = self.star_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, star_target];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_234(self) -> Optional[Any]:
        # _tmp_234: 'as' star_target
        mark = self._mark()
        __true_result = False
        while 1:  # for early false result as in the 'A and B'
            __last = literal = self.expect('as')
            if not __last: break
            __last = star_target = self.star_target()
            if not __last: break
            __true_result = True
            break
        if __true_result:
            return [literal, star_target];
        self._reset(mark)
        return None;

    KEYWORDS = ('False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield')
    SOFT_KEYWORDS = ('_', 'case', 'match')


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(CythonParser)
